<!DOCTYPE html> <head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Эффективный Go</title><link id="favicon" rel="shortcut icon" type="image/png" href="data:image/png;base64,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"></head> <style> 

@font-face {
	font-family: octicons-anchor;
	src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

body {
	background-color: #0d1117;
}

.readme {
	width: 790px;
	display: table;
	margin: 20px auto 20px auto;
	border-radius: 3px;
	border: 1px solid #2a2a2a;
	padding: 30px;
}

.markdown-body {
	-ms-text-size-adjust: 100%;
	-webkit-text-size-adjust: 100%;
	color: #333;
	overflow: hidden;
	font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
	font-size: 16px;
	line-height: 1.6;
	word-wrap: break-word;
}

@media (prefers-color-scheme: dark) {
	.markdown-body,
	[data-theme="dark"] {
	  /*dark*/
	  color-scheme: dark;
	  --color-prettylights-syntax-comment: #8b949e;
	  --color-prettylights-syntax-constant: #79c0ff;
	  --color-prettylights-syntax-entity: #d2a8ff;
	  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
	  --color-prettylights-syntax-entity-tag: #7ee787;
	  --color-prettylights-syntax-keyword: #ff7b72;
	  --color-prettylights-syntax-string: #a5d6ff;
	  --color-prettylights-syntax-variable: #ffa657;
	  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
	  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
	  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
	  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
	  --color-prettylights-syntax-carriage-return-bg: #b62324;
	  --color-prettylights-syntax-string-regexp: #7ee787;
	  --color-prettylights-syntax-markup-list: #f2cc60;
	  --color-prettylights-syntax-markup-heading: #1f6feb;
	  --color-prettylights-syntax-markup-italic: #c9d1d9;
	  --color-prettylights-syntax-markup-bold: #c9d1d9;
	  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
	  --color-prettylights-syntax-markup-deleted-bg: #67060c;
	  --color-prettylights-syntax-markup-inserted-text: #aff5b4;
	  --color-prettylights-syntax-markup-inserted-bg: #033a16;
	  --color-prettylights-syntax-markup-changed-text: #ffdfb6;
	  --color-prettylights-syntax-markup-changed-bg: #5a1e02;
	  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
	  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
	  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
	  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
	  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
	  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
	  --color-fg-default: #e6edf3;
	  --color-fg-muted: #848d97;
	  --color-fg-subtle: #6e7681;
	  --color-canvas-default: #0d1117;
	  --color-canvas-subtle: #161b22;
	  --color-border-default: #30363d;
	  --color-border-muted: #21262d;
	  --color-neutral-muted: rgba(110,118,129,0.4);
	  --color-accent-fg: #2f81f7;
	  --color-accent-emphasis: #1f6feb;
	  --color-success-fg: #3fb950;
	  --color-success-emphasis: #238636;
	  --color-attention-fg: #d29922;
	  --color-attention-emphasis: #9e6a03;
	  --color-attention-subtle: rgba(187,128,9,0.15);
	  --color-danger-fg: #f85149;
	  --color-danger-emphasis: #da3633;
	  --color-done-fg: #a371f7;
	  --color-done-emphasis: #8957e5;
	}
  }
  
  @media (prefers-color-scheme: light) {
	.markdown-body,
	[data-theme="light"] {
	  /*light*/
	  color-scheme: light;
	  --color-prettylights-syntax-comment: #57606a;
	  --color-prettylights-syntax-constant: #0550ae;
	  --color-prettylights-syntax-entity: #6639ba;
	  --color-prettylights-syntax-storage-modifier-import: #24292f;
	  --color-prettylights-syntax-entity-tag: #116329;
	  --color-prettylights-syntax-keyword: #cf222e;
	  --color-prettylights-syntax-string: #0a3069;
	  --color-prettylights-syntax-variable: #953800;
	  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
	  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
	  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
	  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
	  --color-prettylights-syntax-carriage-return-bg: #cf222e;
	  --color-prettylights-syntax-string-regexp: #116329;
	  --color-prettylights-syntax-markup-list: #3b2300;
	  --color-prettylights-syntax-markup-heading: #0550ae;
	  --color-prettylights-syntax-markup-italic: #24292f;
	  --color-prettylights-syntax-markup-bold: #24292f;
	  --color-prettylights-syntax-markup-deleted-text: #82071e;
	  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
	  --color-prettylights-syntax-markup-inserted-text: #116329;
	  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
	  --color-prettylights-syntax-markup-changed-text: #953800;
	  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
	  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
	  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
	  --color-prettylights-syntax-meta-diff-range: #8250df;
	  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
	  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
	  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
	  --color-fg-default: #1F2328;
	  --color-fg-muted: #656d76;
	  --color-fg-subtle: #6e7781;
	  --color-canvas-default: #ffffff;
	  --color-canvas-subtle: #f6f8fa;
	  --color-border-default: #d0d7de;
	  --color-border-muted: hsla(210,18%,87%,1);
	  --color-neutral-muted: rgba(175,184,193,0.2);
	  --color-accent-fg: #0969da;
	  --color-accent-emphasis: #0969da;
	  --color-success-fg: #1a7f37;
	  --color-success-emphasis: #1f883d;
	  --color-attention-fg: #9a6700;
	  --color-attention-emphasis: #9a6700;
	  --color-attention-subtle: #fff8c5;
	  --color-danger-fg: #d1242f;
	  --color-danger-emphasis: #cf222e;
	  --color-done-fg: #8250df;
	  --color-done-emphasis: #8250df;
	}
  }
  
  .markdown-body {
	-ms-text-size-adjust: 100%;
	-webkit-text-size-adjust: 100%;
	margin: 0;
	color: var(--color-fg-default);
	background-color: var(--color-canvas-default);
	font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
	font-size: 16px;
	line-height: 1.5;
	word-wrap: break-word;
  }
  
  .markdown-body .octicon {
	display: inline-block;
	fill: currentColor;
	vertical-align: text-bottom;
  }
  
  .markdown-body h1:hover .anchor .octicon-link:before,
  .markdown-body h2:hover .anchor .octicon-link:before,
  .markdown-body h3:hover .anchor .octicon-link:before,
  .markdown-body h4:hover .anchor .octicon-link:before,
  .markdown-body h5:hover .anchor .octicon-link:before,
  .markdown-body h6:hover .anchor .octicon-link:before {
	width: 16px;
	height: 16px;
	content: ' ';
	display: inline-block;
	background-color: currentColor;
	-webkit-mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
	mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
  }
  
  .markdown-body details,
  .markdown-body figcaption,
  .markdown-body figure {
	display: block;
  }
  
  .markdown-body summary {
	display: list-item;
  }
  
  .markdown-body [hidden] {
	display: none !important;
  }
  
  .markdown-body a {
	background-color: transparent;
	color: var(--color-accent-fg);
	text-decoration: none;
  }
  
  .markdown-body abbr[title] {
	border-bottom: none;
	-webkit-text-decoration: underline dotted;
	text-decoration: underline dotted;
  }
  
  .markdown-body b,
  .markdown-body strong {
	font-weight: var(--base-text-weight-semibold, 600);
  }
  
  .markdown-body dfn {
	font-style: italic;
  }
  
  .markdown-body h1 {
	margin: .67em 0;
	font-weight: var(--base-text-weight-semibold, 600);
	padding-bottom: .3em;
	font-size: 2em;
	border-bottom: 1px solid var(--color-border-muted);
  }
  
  .markdown-body mark {
	background-color: var(--color-attention-subtle);
	color: var(--color-fg-default);
  }
  
  .markdown-body small {
	font-size: 90%;
  }
  
  .markdown-body sub,
  .markdown-body sup {
	font-size: 75%;
	line-height: 0;
	position: relative;
	vertical-align: baseline;
  }
  
  .markdown-body sub {
	bottom: -0.25em;
  }
  
  .markdown-body sup {
	top: -0.5em;
  }
  
  .markdown-body img {
	border-style: none;
	max-width: 100%;
	box-sizing: content-box;
	background-color: var(--color-canvas-default);
  }
  
  .markdown-body code,
  .markdown-body kbd,
  .markdown-body pre,
  .markdown-body samp {
	font-family: monospace;
	font-size: 1em;
  }
  
  .markdown-body figure {
	margin: 1em 40px;
  }
  
  .markdown-body hr {
	box-sizing: content-box;
	overflow: hidden;
	background: transparent;
	border-bottom: 1px solid var(--color-border-muted);
	height: .25em;
	padding: 0;
	margin: 24px 0;
	background-color: var(--color-border-default);
	border: 0;
  }
  
  .markdown-body input {
	font: inherit;
	margin: 0;
	overflow: visible;
	font-family: inherit;
	font-size: inherit;
	line-height: inherit;
  }
  
  .markdown-body [type=button],
  .markdown-body [type=reset],
  .markdown-body [type=submit] {
	-webkit-appearance: button;
	appearance: button;
  }
  
  .markdown-body [type=checkbox],
  .markdown-body [type=radio] {
	box-sizing: border-box;
	padding: 0;
  }
  
  .markdown-body [type=number]::-webkit-inner-spin-button,
  .markdown-body [type=number]::-webkit-outer-spin-button {
	height: auto;
  }
  
  .markdown-body [type=search]::-webkit-search-cancel-button,
  .markdown-body [type=search]::-webkit-search-decoration {
	-webkit-appearance: none;
	appearance: none;
  }
  
  .markdown-body ::-webkit-input-placeholder {
	color: inherit;
	opacity: .54;
  }
  
  .markdown-body ::-webkit-file-upload-button {
	-webkit-appearance: button;
	appearance: button;
	font: inherit;
  }
  
  .markdown-body a:hover {
	text-decoration: underline;
  }
  
  .markdown-body ::placeholder {
	color: var(--color-fg-subtle);
	opacity: 1;
  }
  
  .markdown-body hr::before {
	display: table;
	content: "";
  }
  
  .markdown-body hr::after {
	display: table;
	clear: both;
	content: "";
  }
  
  .markdown-body table {
	border-spacing: 0;
	border-collapse: collapse;
	display: block;
	width: max-content;
	max-width: 100%;
	overflow: auto;
  }
  
  .markdown-body td,
  .markdown-body th {
	padding: 0;
  }
  
  .markdown-body details summary {
	cursor: pointer;
  }
  
  .markdown-body details:not([open])>*:not(summary) {
	display: none !important;
  }
  
  .markdown-body a:focus,
  .markdown-body [role=button]:focus,
  .markdown-body input[type=radio]:focus,
  .markdown-body input[type=checkbox]:focus {
	outline: 2px solid var(--color-accent-fg);
	outline-offset: -2px;
	box-shadow: none;
  }
  
  .markdown-body a:focus:not(:focus-visible),
  .markdown-body [role=button]:focus:not(:focus-visible),
  .markdown-body input[type=radio]:focus:not(:focus-visible),
  .markdown-body input[type=checkbox]:focus:not(:focus-visible) {
	outline: solid 1px transparent;
  }
  
  .markdown-body a:focus-visible,
  .markdown-body [role=button]:focus-visible,
  .markdown-body input[type=radio]:focus-visible,
  .markdown-body input[type=checkbox]:focus-visible {
	outline: 2px solid var(--color-accent-fg);
	outline-offset: -2px;
	box-shadow: none;
  }
  
  .markdown-body a:not([class]):focus,
  .markdown-body a:not([class]):focus-visible,
  .markdown-body input[type=radio]:focus,
  .markdown-body input[type=radio]:focus-visible,
  .markdown-body input[type=checkbox]:focus,
  .markdown-body input[type=checkbox]:focus-visible {
	outline-offset: 0;
  }
  
  .markdown-body kbd {
	display: inline-block;
	padding: 3px 5px;
	font: 11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
	line-height: 10px;
	color: var(--color-fg-default);
	vertical-align: middle;
	background-color: var(--color-canvas-subtle);
	border: solid 1px var(--color-neutral-muted);
	border-bottom-color: var(--color-neutral-muted);
	border-radius: 6px;
	box-shadow: inset 0 -1px 0 var(--color-neutral-muted);
  }
  
  .markdown-body h1,
  .markdown-body h2,
  .markdown-body h3,
  .markdown-body h4,
  .markdown-body h5,
  .markdown-body h6 {
	margin-top: 24px;
	margin-bottom: 16px;
	font-weight: var(--base-text-weight-semibold, 600);
	line-height: 1.25;
  }
  
  .markdown-body h2 {
	font-weight: var(--base-text-weight-semibold, 600);
	padding-bottom: .3em;
	font-size: 1.5em;
	border-bottom: 1px solid var(--color-border-muted);
  }
  
  .markdown-body h3 {
	font-weight: var(--base-text-weight-semibold, 600);
	font-size: 1.25em;
  }
  
  .markdown-body h4 {
	font-weight: var(--base-text-weight-semibold, 600);
	font-size: 1em;
  }
  
  .markdown-body h5 {
	font-weight: var(--base-text-weight-semibold, 600);
	font-size: .875em;
  }
  
  .markdown-body h6 {
	font-weight: var(--base-text-weight-semibold, 600);
	font-size: .85em;
	color: var(--color-fg-muted);
  }
  
  .markdown-body p {
	margin-top: 0;
	margin-bottom: 10px;
  }
  
  .markdown-body blockquote {
	margin: 0;
	padding: 0 1em;
	color: var(--color-fg-muted);
	border-left: .25em solid var(--color-border-default);
  }
  
  .markdown-body ul,
  .markdown-body ol {
	margin-top: 0;
	margin-bottom: 0;
	padding-left: 2em;
  }
  
  .markdown-body ol ol,
  .markdown-body ul ol {
	list-style-type: lower-roman;
  }
  
  .markdown-body ul ul ol,
  .markdown-body ul ol ol,
  .markdown-body ol ul ol,
  .markdown-body ol ol ol {
	list-style-type: lower-alpha;
  }
  
  .markdown-body dd {
	margin-left: 0;
  }
  
  .markdown-body tt,
  .markdown-body code,
  .markdown-body samp {
	font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
	font-size: 12px;
  }
  
  .markdown-body pre {
	margin-top: 0;
	margin-bottom: 0;
	font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
	font-size: 12px;
	word-wrap: normal;
  }
  
  .markdown-body .octicon {
	display: inline-block;
	overflow: visible !important;
	vertical-align: text-bottom;
	fill: currentColor;
  }
  
  .markdown-body input::-webkit-outer-spin-button,
  .markdown-body input::-webkit-inner-spin-button {
	margin: 0;
	-webkit-appearance: none;
	appearance: none;
  }
  
  .markdown-body .mr-2 {
	margin-right: var(--base-size-8, 8px) !important;
  }
  
  .markdown-body::before {
	display: table;
	content: "";
  }
  
  .markdown-body::after {
	display: table;
	clear: both;
	content: "";
  }
  
  .markdown-body>*:first-child {
	margin-top: 0 !important;
  }
  
  .markdown-body>*:last-child {
	margin-bottom: 0 !important;
  }
  
  .markdown-body a:not([href]) {
	color: inherit;
	text-decoration: none;
  }
  
  .markdown-body .absent {
	color: var(--color-danger-fg);
  }
  
  .markdown-body .anchor {
	float: left;
	padding-right: 4px;
	margin-left: -20px;
	line-height: 1;
  }
  
  .markdown-body .anchor:focus {
	outline: none;
  }
  
  .markdown-body p,
  .markdown-body blockquote,
  .markdown-body ul,
  .markdown-body ol,
  .markdown-body dl,
  .markdown-body table,
  .markdown-body pre,
  .markdown-body details {
	margin-top: 0;
	margin-bottom: 16px;
  }
  
  .markdown-body blockquote>:first-child {
	margin-top: 0;
  }
  
  .markdown-body blockquote>:last-child {
	margin-bottom: 0;
  }
  
  .markdown-body h1 .octicon-link,
  .markdown-body h2 .octicon-link,
  .markdown-body h3 .octicon-link,
  .markdown-body h4 .octicon-link,
  .markdown-body h5 .octicon-link,
  .markdown-body h6 .octicon-link {
	color: var(--color-fg-default);
	vertical-align: middle;
	visibility: hidden;
  }
  
  .markdown-body h1:hover .anchor,
  .markdown-body h2:hover .anchor,
  .markdown-body h3:hover .anchor,
  .markdown-body h4:hover .anchor,
  .markdown-body h5:hover .anchor,
  .markdown-body h6:hover .anchor {
	text-decoration: none;
  }
  
  .markdown-body h1:hover .anchor .octicon-link,
  .markdown-body h2:hover .anchor .octicon-link,
  .markdown-body h3:hover .anchor .octicon-link,
  .markdown-body h4:hover .anchor .octicon-link,
  .markdown-body h5:hover .anchor .octicon-link,
  .markdown-body h6:hover .anchor .octicon-link {
	visibility: visible;
  }
  
  .markdown-body h1 tt,
  .markdown-body h1 code,
  .markdown-body h2 tt,
  .markdown-body h2 code,
  .markdown-body h3 tt,
  .markdown-body h3 code,
  .markdown-body h4 tt,
  .markdown-body h4 code,
  .markdown-body h5 tt,
  .markdown-body h5 code,
  .markdown-body h6 tt,
  .markdown-body h6 code {
	padding: 0 .2em;
	font-size: inherit;
  }
  
  .markdown-body summary h1,
  .markdown-body summary h2,
  .markdown-body summary h3,
  .markdown-body summary h4,
  .markdown-body summary h5,
  .markdown-body summary h6 {
	display: inline-block;
  }
  
  .markdown-body summary h1 .anchor,
  .markdown-body summary h2 .anchor,
  .markdown-body summary h3 .anchor,
  .markdown-body summary h4 .anchor,
  .markdown-body summary h5 .anchor,
  .markdown-body summary h6 .anchor {
	margin-left: -40px;
  }
  
  .markdown-body summary h1,
  .markdown-body summary h2 {
	padding-bottom: 0;
	border-bottom: 0;
  }
  
  .markdown-body ul.no-list,
  .markdown-body ol.no-list {
	padding: 0;
	list-style-type: none;
  }
  
  .markdown-body ol[type="a s"] {
	list-style-type: lower-alpha;
  }
  
  .markdown-body ol[type="A s"] {
	list-style-type: upper-alpha;
  }
  
  .markdown-body ol[type="i s"] {
	list-style-type: lower-roman;
  }
  
  .markdown-body ol[type="I s"] {
	list-style-type: upper-roman;
  }
  
  .markdown-body ol[type="1"] {
	list-style-type: decimal;
  }
  
  .markdown-body div>ol:not([type]) {
	list-style-type: decimal;
  }
  
  .markdown-body ul ul,
  .markdown-body ul ol,
  .markdown-body ol ol,
  .markdown-body ol ul {
	margin-top: 0;
	margin-bottom: 0;
  }
  
  .markdown-body li>p {
	margin-top: 16px;
  }
  
  .markdown-body li+li {
	margin-top: .25em;
  }
  
  .markdown-body dl {
	padding: 0;
  }
  
  .markdown-body dl dt {
	padding: 0;
	margin-top: 16px;
	font-size: 1em;
	font-style: italic;
	font-weight: var(--base-text-weight-semibold, 600);
  }
  
  .markdown-body dl dd {
	padding: 0 16px;
	margin-bottom: 16px;
  }
  
  .markdown-body table th {
	font-weight: var(--base-text-weight-semibold, 600);
  }
  
  .markdown-body table th,
  .markdown-body table td {
	padding: 6px 13px;
	border: 1px solid var(--color-border-default);
  }
  
  .markdown-body table td>:last-child {
	margin-bottom: 0;
  }
  
  .markdown-body table tr {
	background-color: var(--color-canvas-default);
	border-top: 1px solid var(--color-border-muted);
  }
  
  .markdown-body table tr:nth-child(2n) {
	background-color: var(--color-canvas-subtle);
  }
  
  .markdown-body table img {
	background-color: transparent;
  }
  
  .markdown-body img[align=right] {
	padding-left: 20px;
  }
  
  .markdown-body img[align=left] {
	padding-right: 20px;
  }
  
  .markdown-body .emoji {
	max-width: none;
	vertical-align: text-top;
	background-color: transparent;
  }
  
  .markdown-body span.frame {
	display: block;
	overflow: hidden;
  }
  
  .markdown-body span.frame>span {
	display: block;
	float: left;
	width: auto;
	padding: 7px;
	margin: 13px 0 0;
	overflow: hidden;
	border: 1px solid var(--color-border-default);
  }
  
  .markdown-body span.frame span img {
	display: block;
	float: left;
  }
  
  .markdown-body span.frame span span {
	display: block;
	padding: 5px 0 0;
	clear: both;
	color: var(--color-fg-default);
  }
  
  .markdown-body span.align-center {
	display: block;
	overflow: hidden;
	clear: both;
  }
  
  .markdown-body span.align-center>span {
	display: block;
	margin: 13px auto 0;
	overflow: hidden;
	text-align: center;
  }
  
  .markdown-body span.align-center span img {
	margin: 0 auto;
	text-align: center;
  }
  
  .markdown-body span.align-right {
	display: block;
	overflow: hidden;
	clear: both;
  }
  
  .markdown-body span.align-right>span {
	display: block;
	margin: 13px 0 0;
	overflow: hidden;
	text-align: right;
  }
  
  .markdown-body span.align-right span img {
	margin: 0;
	text-align: right;
  }
  
  .markdown-body span.float-left {
	display: block;
	float: left;
	margin-right: 13px;
	overflow: hidden;
  }
  
  .markdown-body span.float-left span {
	margin: 13px 0 0;
  }
  
  .markdown-body span.float-right {
	display: block;
	float: right;
	margin-left: 13px;
	overflow: hidden;
  }
  
  .markdown-body span.float-right>span {
	display: block;
	margin: 13px auto 0;
	overflow: hidden;
	text-align: right;
  }
  
  .markdown-body code,
  .markdown-body tt {
	padding: .2em .4em;
	margin: 0;
	font-size: 85%;
	white-space: break-spaces;
	background-color: var(--color-neutral-muted);
	border-radius: 6px;
  }
  
  .markdown-body code br,
  .markdown-body tt br {
	display: none;
  }
  
  .markdown-body del code {
	text-decoration: inherit;
  }
  
  .markdown-body samp {
	font-size: 85%;
  }
  
  .markdown-body pre code {
	font-size: 100%;
  }
  
  .markdown-body pre>code {
	padding: 0;
	margin: 0;
	word-break: normal;
	white-space: pre;
	background: transparent;
	border: 0;
  }
  
  .markdown-body .highlight {
	margin-bottom: 16px;
  }
  
  .markdown-body .highlight pre {
	margin-bottom: 0;
	word-break: normal;
  }
  
  .markdown-body .highlight pre,
  .markdown-body pre {
	padding: 16px;
	overflow: auto;
	font-size: 85%;
	line-height: 1.45;
	color: var(--color-fg-default);
	background-color: var(--color-canvas-subtle);
	border-radius: 6px;
  }
  
  .markdown-body pre code,
  .markdown-body pre tt {
	display: inline;
	max-width: auto;
	padding: 0;
	margin: 0;
	overflow: visible;
	line-height: inherit;
	word-wrap: normal;
	background-color: transparent;
	border: 0;
  }
  
  .markdown-body .csv-data td,
  .markdown-body .csv-data th {
	padding: 5px;
	overflow: hidden;
	font-size: 12px;
	line-height: 1;
	text-align: left;
	white-space: nowrap;
  }
  
  .markdown-body .csv-data .blob-num {
	padding: 10px 8px 9px;
	text-align: right;
	background: var(--color-canvas-default);
	border: 0;
  }
  
  .markdown-body .csv-data tr {
	border-top: 0;
  }
  
  .markdown-body .csv-data th {
	font-weight: var(--base-text-weight-semibold, 600);
	background: var(--color-canvas-subtle);
	border-top: 0;
  }
  
  .markdown-body [data-footnote-ref]::before {
	content: "[";
  }
  
  .markdown-body [data-footnote-ref]::after {
	content: "]";
  }
  
  .markdown-body .footnotes {
	font-size: 12px;
	color: var(--color-fg-muted);
	border-top: 1px solid var(--color-border-default);
  }
  
  .markdown-body .footnotes ol {
	padding-left: 16px;
  }
  
  .markdown-body .footnotes ol ul {
	display: inline-block;
	padding-left: 16px;
	margin-top: 16px;
  }
  
  .markdown-body .footnotes li {
	position: relative;
  }
  
  .markdown-body .footnotes li:target::before {
	position: absolute;
	top: -8px;
	right: -8px;
	bottom: -8px;
	left: -24px;
	pointer-events: none;
	content: "";
	border: 2px solid var(--color-accent-emphasis);
	border-radius: 6px;
  }
  
  .markdown-body .footnotes li:target {
	color: var(--color-fg-default);
  }
  
  .markdown-body .footnotes .data-footnote-backref g-emoji {
	font-family: monospace;
  }
  
  .markdown-body .pl-c {
	color: var(--color-prettylights-syntax-comment);
  }
  
  .markdown-body .pl-c1,
  .markdown-body .pl-s .pl-v {
	color: var(--color-prettylights-syntax-constant);
  }
  
  .markdown-body .pl-e,
  .markdown-body .pl-en {
	color: var(--color-prettylights-syntax-entity);
  }
  
  .markdown-body .pl-smi,
  .markdown-body .pl-s .pl-s1 {
	color: var(--color-prettylights-syntax-storage-modifier-import);
  }
  
  .markdown-body .pl-ent {
	color: var(--color-prettylights-syntax-entity-tag);
  }
  
  .markdown-body .pl-k {
	color: var(--color-prettylights-syntax-keyword);
  }
  
  .markdown-body .pl-s,
  .markdown-body .pl-pds,
  .markdown-body .pl-s .pl-pse .pl-s1,
  .markdown-body .pl-sr,
  .markdown-body .pl-sr .pl-cce,
  .markdown-body .pl-sr .pl-sre,
  .markdown-body .pl-sr .pl-sra {
	color: var(--color-prettylights-syntax-string);
  }
  
  .markdown-body .pl-v,
  .markdown-body .pl-smw {
	color: var(--color-prettylights-syntax-variable);
  }
  
  .markdown-body .pl-bu {
	color: var(--color-prettylights-syntax-brackethighlighter-unmatched);
  }
  
  .markdown-body .pl-ii {
	color: var(--color-prettylights-syntax-invalid-illegal-text);
	background-color: var(--color-prettylights-syntax-invalid-illegal-bg);
  }
  
  .markdown-body .pl-c2 {
	color: var(--color-prettylights-syntax-carriage-return-text);
	background-color: var(--color-prettylights-syntax-carriage-return-bg);
  }
  
  .markdown-body .pl-sr .pl-cce {
	font-weight: bold;
	color: var(--color-prettylights-syntax-string-regexp);
  }
  
  .markdown-body .pl-ml {
	color: var(--color-prettylights-syntax-markup-list);
  }
  
  .markdown-body .pl-mh,
  .markdown-body .pl-mh .pl-en,
  .markdown-body .pl-ms {
	font-weight: bold;
	color: var(--color-prettylights-syntax-markup-heading);
  }
  
  .markdown-body .pl-mi {
	font-style: italic;
	color: var(--color-prettylights-syntax-markup-italic);
  }
  
  .markdown-body .pl-mb {
	font-weight: bold;
	color: var(--color-prettylights-syntax-markup-bold);
  }
  
  .markdown-body .pl-md {
	color: var(--color-prettylights-syntax-markup-deleted-text);
	background-color: var(--color-prettylights-syntax-markup-deleted-bg);
  }
  
  .markdown-body .pl-mi1 {
	color: var(--color-prettylights-syntax-markup-inserted-text);
	background-color: var(--color-prettylights-syntax-markup-inserted-bg);
  }
  
  .markdown-body .pl-mc {
	color: var(--color-prettylights-syntax-markup-changed-text);
	background-color: var(--color-prettylights-syntax-markup-changed-bg);
  }
  
  .markdown-body .pl-mi2 {
	color: var(--color-prettylights-syntax-markup-ignored-text);
	background-color: var(--color-prettylights-syntax-markup-ignored-bg);
  }
  
  .markdown-body .pl-mdr {
	font-weight: bold;
	color: var(--color-prettylights-syntax-meta-diff-range);
  }
  
  .markdown-body .pl-ba {
	color: var(--color-prettylights-syntax-brackethighlighter-angle);
  }
  
  .markdown-body .pl-sg {
	color: var(--color-prettylights-syntax-sublimelinter-gutter-mark);
  }
  
  .markdown-body .pl-corl {
	text-decoration: underline;
	color: var(--color-prettylights-syntax-constant-other-reference-link);
  }
  
  .markdown-body g-emoji {
	display: inline-block;
	min-width: 1ch;
	font-family: "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
	font-size: 1em;
	font-style: normal !important;
	font-weight: var(--base-text-weight-normal, 400);
	line-height: 1;
	vertical-align: -0.075em;
  }
  
  .markdown-body g-emoji img {
	width: 1em;
	height: 1em;
  }
  
  .markdown-body .task-list-item {
	list-style-type: none;
  }
  
  .markdown-body .task-list-item label {
	font-weight: var(--base-text-weight-normal, 400);
  }
  
  .markdown-body .task-list-item.enabled label {
	cursor: pointer;
  }
  
  .markdown-body .task-list-item+.task-list-item {
	margin-top: 4px;
  }
  
  .markdown-body .task-list-item .handle {
	display: none;
  }
  
  .markdown-body .task-list-item-checkbox {
	margin: 0 .2em .25em -1.4em;
	vertical-align: middle;
  }
  
  .markdown-body .contains-task-list:dir(rtl) .task-list-item-checkbox {
	margin: 0 -1.6em .25em .2em;
  }
  
  .markdown-body .contains-task-list {
	position: relative;
  }
  
  .markdown-body .contains-task-list:hover .task-list-item-convert-container,
  .markdown-body .contains-task-list:focus-within .task-list-item-convert-container {
	display: block;
	width: auto;
	height: 24px;
	overflow: visible;
	clip: auto;
  }
  
  .markdown-body ::-webkit-calendar-picker-indicator {
	filter: invert(50%);
  }
  
  .markdown-body .markdown-alert {
	padding: var(--base-size-8) var(--base-size-16);
	margin-bottom: 16px;
	color: inherit;
	border-left: .25em solid var(--color-border-default);
  }
  
  .markdown-body .markdown-alert>:first-child {
	margin-top: 0;
  }
  
  .markdown-body .markdown-alert>:last-child {
	margin-bottom: 0;
  }
  
  .markdown-body .markdown-alert .markdown-alert-title {
	display: flex;
	font-weight: var(--base-text-weight-medium, 500);
	align-items: center;
	line-height: 1;
  }
  
  .markdown-body .markdown-alert.markdown-alert-note {
	border-left-color: var(--color-accent-emphasis);
  }
  
  .markdown-body .markdown-alert.markdown-alert-note .markdown-alert-title {
	color: var(--color-accent-fg);
  }
  
  .markdown-body .markdown-alert.markdown-alert-important {
	border-left-color: var(--color-done-emphasis);
  }
  
  .markdown-body .markdown-alert.markdown-alert-important .markdown-alert-title {
	color: var(--color-done-fg);
  }
  
  .markdown-body .markdown-alert.markdown-alert-warning {
	border-left-color: var(--color-attention-emphasis);
  }
  
  .markdown-body .markdown-alert.markdown-alert-warning .markdown-alert-title {
	color: var(--color-attention-fg);
  }
  
  .markdown-body .markdown-alert.markdown-alert-tip {
	border-left-color: var(--color-success-emphasis);
  }
  
  .markdown-body .markdown-alert.markdown-alert-tip .markdown-alert-title {
	color: var(--color-success-fg);
  }
  
  .markdown-body .markdown-alert.markdown-alert-caution {
	border-left-color: var(--color-danger-emphasis);
  }
  
  .markdown-body .markdown-alert.markdown-alert-caution .markdown-alert-title {
	color: var(--color-danger-fg);
  }

  /*dark*/

.markdown-body {
  color-scheme: dark;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  margin: 0;
  color: #e6edf3;
  background-color: #0d1117;
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.markdown-body .octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.markdown-body h1:hover .anchor .octicon-link:before,
.markdown-body h2:hover .anchor .octicon-link:before,
.markdown-body h3:hover .anchor .octicon-link:before,
.markdown-body h4:hover .anchor .octicon-link:before,
.markdown-body h5:hover .anchor .octicon-link:before,
.markdown-body h6:hover .anchor .octicon-link:before {
  width: 16px;
  height: 16px;
  content: ' ';
  display: inline-block;
  background-color: currentColor;
  -webkit-mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
  mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
}

.markdown-body details,
.markdown-body figcaption,
.markdown-body figure {
  display: block;
}

.markdown-body summary {
  display: list-item;
}

.markdown-body [hidden] {
  display: none !important;
}

.markdown-body a {
  background-color: transparent;
  color: #2f81f7;
  text-decoration: none;
}

.markdown-body abbr[title] {
  border-bottom: none;
  -webkit-text-decoration: underline dotted;
  text-decoration: underline dotted;
}

.markdown-body b,
.markdown-body strong {
  font-weight: 600;
}

.markdown-body dfn {
  font-style: italic;
}

.markdown-body h1 {
  margin: .67em 0;
  font-weight: 600;
  padding-bottom: .3em;
  font-size: 2em;
  border-bottom: 1px solid #21262d;
}

.markdown-body mark {
  background-color: rgba(187,128,9,0.15);
  color: #e6edf3;
}

.markdown-body small {
  font-size: 90%;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body sup {
  top: -0.5em;
}

.markdown-body img {
  border-style: none;
  max-width: 100%;
  box-sizing: content-box;
  background-color: #0d1117;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace;
  font-size: 1em;
}

.markdown-body figure {
  margin: 1em 40px;
}

.markdown-body hr {
  box-sizing: content-box;
  overflow: hidden;
  background: transparent;
  border-bottom: 1px solid #21262d;
  height: .25em;
  padding: 0;
  margin: 24px 0;
  background-color: #30363d;
  border: 0;
}

.markdown-body input {
  font: inherit;
  margin: 0;
  overflow: visible;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body [type=button],
.markdown-body [type=reset],
.markdown-body [type=submit] {
  -webkit-appearance: button;
  appearance: button;
}

.markdown-body [type=checkbox],
.markdown-body [type=radio] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body [type=number]::-webkit-inner-spin-button,
.markdown-body [type=number]::-webkit-outer-spin-button {
  height: auto;
}

.markdown-body [type=search]::-webkit-search-cancel-button,
.markdown-body [type=search]::-webkit-search-decoration {
  -webkit-appearance: none;
  appearance: none;
}

.markdown-body ::-webkit-input-placeholder {
  color: inherit;
  opacity: .54;
}

.markdown-body ::-webkit-file-upload-button {
  -webkit-appearance: button;
  appearance: button;
  font: inherit;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body ::placeholder {
  color: #6e7681;
  opacity: 1;
}

.markdown-body hr::before {
  display: table;
  content: "";
}

.markdown-body hr::after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body table {
  border-spacing: 0;
  border-collapse: collapse;
  display: block;
  width: max-content;
  max-width: 100%;
  overflow: auto;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body details summary {
  cursor: pointer;
}

.markdown-body details:not([open])>*:not(summary) {
  display: none !important;
}

.markdown-body a:focus,
.markdown-body [role=button]:focus,
.markdown-body input[type=radio]:focus,
.markdown-body input[type=checkbox]:focus {
  outline: 2px solid #2f81f7;
  outline-offset: -2px;
  box-shadow: none;
}

.markdown-body a:focus:not(:focus-visible),
.markdown-body [role=button]:focus:not(:focus-visible),
.markdown-body input[type=radio]:focus:not(:focus-visible),
.markdown-body input[type=checkbox]:focus:not(:focus-visible) {
  outline: solid 1px transparent;
}

.markdown-body a:focus-visible,
.markdown-body [role=button]:focus-visible,
.markdown-body input[type=radio]:focus-visible,
.markdown-body input[type=checkbox]:focus-visible {
  outline: 2px solid #2f81f7;
  outline-offset: -2px;
  box-shadow: none;
}

.markdown-body a:not([class]):focus,
.markdown-body a:not([class]):focus-visible,
.markdown-body input[type=radio]:focus,
.markdown-body input[type=radio]:focus-visible,
.markdown-body input[type=checkbox]:focus,
.markdown-body input[type=checkbox]:focus-visible {
  outline-offset: 0;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  line-height: 10px;
  color: #e6edf3;
  vertical-align: middle;
  background-color: #161b22;
  border: solid 1px rgba(110,118,129,0.4);
  border-bottom-color: rgba(110,118,129,0.4);
  border-radius: 6px;
  box-shadow: inset 0 -1px 0 rgba(110,118,129,0.4);
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
}

.markdown-body h2 {
  font-weight: 600;
  padding-bottom: .3em;
  font-size: 1.5em;
  border-bottom: 1px solid #21262d;
}

.markdown-body h3 {
  font-weight: 600;
  font-size: 1.25em;
}

.markdown-body h4 {
  font-weight: 600;
  font-size: 1em;
}

.markdown-body h5 {
  font-weight: 600;
  font-size: .875em;
}

.markdown-body h6 {
  font-weight: 600;
  font-size: .85em;
  color: #848d97;
}

.markdown-body p {
  margin-top: 0;
  margin-bottom: 10px;
}

.markdown-body blockquote {
  margin: 0;
  padding: 0 1em;
  color: #848d97;
  border-left: .25em solid #30363d;
}

.markdown-body ul,
.markdown-body ol {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 2em;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body tt,
.markdown-body code,
.markdown-body samp {
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
  word-wrap: normal;
}

.markdown-body .octicon {
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-body input::-webkit-outer-spin-button,
.markdown-body input::-webkit-inner-spin-button {
  margin: 0;
  -webkit-appearance: none;
  appearance: none;
}

.markdown-body .mr-2 {
  margin-right: 8px !important;
}

.markdown-body::before {
  display: table;
  content: "";
}

.markdown-body::after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body .absent {
  color: #f85149;
}

.markdown-body .anchor {
  float: left;
  padding-right: 4px;
  margin-left: -20px;
  line-height: 1;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body details {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #e6edf3;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body h1 tt,
.markdown-body h1 code,
.markdown-body h2 tt,
.markdown-body h2 code,
.markdown-body h3 tt,
.markdown-body h3 code,
.markdown-body h4 tt,
.markdown-body h4 code,
.markdown-body h5 tt,
.markdown-body h5 code,
.markdown-body h6 tt,
.markdown-body h6 code {
  padding: 0 .2em;
  font-size: inherit;
}

.markdown-body summary h1,
.markdown-body summary h2,
.markdown-body summary h3,
.markdown-body summary h4,
.markdown-body summary h5,
.markdown-body summary h6 {
  display: inline-block;
}

.markdown-body summary h1 .anchor,
.markdown-body summary h2 .anchor,
.markdown-body summary h3 .anchor,
.markdown-body summary h4 .anchor,
.markdown-body summary h5 .anchor,
.markdown-body summary h6 .anchor {
  margin-left: -40px;
}

.markdown-body summary h1,
.markdown-body summary h2 {
  padding-bottom: 0;
  border-bottom: 0;
}

.markdown-body ul.no-list,
.markdown-body ol.no-list {
  padding: 0;
  list-style-type: none;
}

.markdown-body ol[type="a s"] {
  list-style-type: lower-alpha;
}

.markdown-body ol[type="A s"] {
  list-style-type: upper-alpha;
}

.markdown-body ol[type="i s"] {
  list-style-type: lower-roman;
}

.markdown-body ol[type="I s"] {
  list-style-type: upper-roman;
}

.markdown-body ol[type="1"] {
  list-style-type: decimal;
}

.markdown-body div>ol:not([type]) {
  list-style-type: decimal;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body li+li {
  margin-top: .25em;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body table th {
  font-weight: 600;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #30363d;
}

.markdown-body table td>:last-child {
  margin-bottom: 0;
}

.markdown-body table tr {
  background-color: #0d1117;
  border-top: 1px solid #21262d;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #161b22;
}

.markdown-body table img {
  background-color: transparent;
}

.markdown-body img[align=right] {
  padding-left: 20px;
}

.markdown-body img[align=left] {
  padding-right: 20px;
}

.markdown-body .emoji {
  max-width: none;
  vertical-align: text-top;
  background-color: transparent;
}

.markdown-body span.frame {
  display: block;
  overflow: hidden;
}

.markdown-body span.frame>span {
  display: block;
  float: left;
  width: auto;
  padding: 7px;
  margin: 13px 0 0;
  overflow: hidden;
  border: 1px solid #30363d;
}

.markdown-body span.frame span img {
  display: block;
  float: left;
}

.markdown-body span.frame span span {
  display: block;
  padding: 5px 0 0;
  clear: both;
  color: #e6edf3;
}

.markdown-body span.align-center {
  display: block;
  overflow: hidden;
  clear: both;
}

.markdown-body span.align-center>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: center;
}

.markdown-body span.align-center span img {
  margin: 0 auto;
  text-align: center;
}

.markdown-body span.align-right {
  display: block;
  overflow: hidden;
  clear: both;
}

.markdown-body span.align-right>span {
  display: block;
  margin: 13px 0 0;
  overflow: hidden;
  text-align: right;
}

.markdown-body span.align-right span img {
  margin: 0;
  text-align: right;
}

.markdown-body span.float-left {
  display: block;
  float: left;
  margin-right: 13px;
  overflow: hidden;
}

.markdown-body span.float-left span {
  margin: 13px 0 0;
}

.markdown-body span.float-right {
  display: block;
  float: right;
  margin-left: 13px;
  overflow: hidden;
}

.markdown-body span.float-right>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: right;
}

.markdown-body code,
.markdown-body tt {
  padding: .2em .4em;
  margin: 0;
  font-size: 85%;
  white-space: break-spaces;
  background-color: rgba(110,118,129,0.4);
  border-radius: 6px;
}

.markdown-body code br,
.markdown-body tt br {
  display: none;
}

.markdown-body del code {
  text-decoration: inherit;
}

.markdown-body samp {
  font-size: 85%;
}

.markdown-body pre code {
  font-size: 100%;
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  color: #e6edf3;
  background-color: #161b22;
  border-radius: 6px;
}

.markdown-body pre code,
.markdown-body pre tt {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body .csv-data td,
.markdown-body .csv-data th {
  padding: 5px;
  overflow: hidden;
  font-size: 12px;
  line-height: 1;
  text-align: left;
  white-space: nowrap;
}

.markdown-body .csv-data .blob-num {
  padding: 10px 8px 9px;
  text-align: right;
  background: #0d1117;
  border: 0;
}

.markdown-body .csv-data tr {
  border-top: 0;
}

.markdown-body .csv-data th {
  font-weight: 600;
  background: #161b22;
  border-top: 0;
}

.markdown-body [data-footnote-ref]::before {
  content: "[";
}

.markdown-body [data-footnote-ref]::after {
  content: "]";
}

.markdown-body .footnotes {
  font-size: 12px;
  color: #848d97;
  border-top: 1px solid #30363d;
}

.markdown-body .footnotes ol {
  padding-left: 16px;
}

.markdown-body .footnotes ol ul {
  display: inline-block;
  padding-left: 16px;
  margin-top: 16px;
}

.markdown-body .footnotes li {
  position: relative;
}

.markdown-body .footnotes li:target::before {
  position: absolute;
  top: -8px;
  right: -8px;
  bottom: -8px;
  left: -24px;
  pointer-events: none;
  content: "";
  border: 2px solid #1f6feb;
  border-radius: 6px;
}

.markdown-body .footnotes li:target {
  color: #e6edf3;
}

.markdown-body .footnotes .data-footnote-backref g-emoji {
  font-family: monospace;
}

.markdown-body .pl-c {
  color: #8b949e;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #79c0ff;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #d2a8ff;
}

.markdown-body .pl-smi,
.markdown-body .pl-s .pl-s1 {
  color: #c9d1d9;
}

.markdown-body .pl-ent {
  color: #7ee787;
}

.markdown-body .pl-k {
  color: #ff7b72;
}

.markdown-body .pl-s,
.markdown-body .pl-pds,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sre,
.markdown-body .pl-sr .pl-sra {
  color: #a5d6ff;
}

.markdown-body .pl-v,
.markdown-body .pl-smw {
  color: #ffa657;
}

.markdown-body .pl-bu {
  color: #f85149;
}

.markdown-body .pl-ii {
  color: #f0f6fc;
  background-color: #8e1519;
}

.markdown-body .pl-c2 {
  color: #f0f6fc;
  background-color: #b62324;
}

.markdown-body .pl-sr .pl-cce {
  font-weight: bold;
  color: #7ee787;
}

.markdown-body .pl-ml {
  color: #f2cc60;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  font-weight: bold;
  color: #1f6feb;
}

.markdown-body .pl-mi {
  font-style: italic;
  color: #c9d1d9;
}

.markdown-body .pl-mb {
  font-weight: bold;
  color: #c9d1d9;
}

.markdown-body .pl-md {
  color: #ffdcd7;
  background-color: #67060c;
}

.markdown-body .pl-mi1 {
  color: #aff5b4;
  background-color: #033a16;
}

.markdown-body .pl-mc {
  color: #ffdfb6;
  background-color: #5a1e02;
}

.markdown-body .pl-mi2 {
  color: #c9d1d9;
  background-color: #1158c7;
}

.markdown-body .pl-mdr {
  font-weight: bold;
  color: #d2a8ff;
}

.markdown-body .pl-ba {
  color: #8b949e;
}

.markdown-body .pl-sg {
  color: #484f58;
}

.markdown-body .pl-corl {
  text-decoration: underline;
  color: #a5d6ff;
}

.markdown-body g-emoji {
  display: inline-block;
  min-width: 1ch;
  font-family: "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
  font-size: 1em;
  font-style: normal !important;
  font-weight: 400;
  line-height: 1;
  vertical-align: -0.075em;
}

.markdown-body g-emoji img {
  width: 1em;
  height: 1em;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item label {
  font-weight: 400;
}

.markdown-body .task-list-item.enabled label {
  cursor: pointer;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 4px;
}

.markdown-body .task-list-item .handle {
  display: none;
}

.markdown-body .task-list-item-checkbox {
  margin: 0 .2em .25em -1.4em;
  vertical-align: middle;
}

.markdown-body .contains-task-list:dir(rtl) .task-list-item-checkbox {
  margin: 0 -1.6em .25em .2em;
}

.markdown-body .contains-task-list {
  position: relative;
}

.markdown-body .contains-task-list:hover .task-list-item-convert-container,
.markdown-body .contains-task-list:focus-within .task-list-item-convert-container {
  display: block;
  width: auto;
  height: 24px;
  overflow: visible;
  clip: auto;
}

.markdown-body ::-webkit-calendar-picker-indicator {
  filter: invert(50%);
}

.markdown-body .markdown-alert {
  padding: 8px 16px;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #30363d;
}

.markdown-body .markdown-alert>:first-child {
  margin-top: 0;
}

.markdown-body .markdown-alert>:last-child {
  margin-bottom: 0;
}

.markdown-body .markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1;
}

.markdown-body .markdown-alert.markdown-alert-note {
  border-left-color: #1f6feb;
}

.markdown-body .markdown-alert.markdown-alert-note .markdown-alert-title {
  color: #2f81f7;
}

.markdown-body .markdown-alert.markdown-alert-important {
  border-left-color: #8957e5;
}

.markdown-body .markdown-alert.markdown-alert-important .markdown-alert-title {
  color: #a371f7;
}

.markdown-body .markdown-alert.markdown-alert-warning {
  border-left-color: #9e6a03;
}

.markdown-body .markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: #d29922;
}

.markdown-body .markdown-alert.markdown-alert-tip {
  border-left-color: #238636;
}

.markdown-body .markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: #3fb950;
}

.markdown-body .markdown-alert.markdown-alert-caution {
  border-left-color: #da3633;
}

.markdown-body .markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: #f85149;
}
 </style><body><div class="readme"><article class="markdown-body">
<html><head></head><body><h1 id="VaHytEwbBZvqpxhu">Effective Go (RU) (Эффективный Go)</h1>
<hr/>
<p>Оригинал смотри: <a href="https://golang.org/doc/effective_go.html" rel="nofollow">https://golang.org/doc/effective_go.html</a><br/>
<code class="notranslate">go version go1.7.4</code></p>
<hr/>
<p><strong>Список дополнительных материалов:</strong></p>
<ul>
<li><a href="https://github.com/Konstantin8105/Contribution_Guide_RU">Руководство сотрудничества</a></li>
<li><a href="https://github.com/Konstantin8105/Effective_Go_RU">Эффективный Go</a></li>
</ul>
<hr/>
<h1 id="KEjPZrtQtALYWoQv">Оглавление</h1>
<ul>
<li><a href="#SEmSMFZuEewLduBl">Введение</a></li>
<li><a href="#arhNVdJgdhXVLPJZ">Примеры</a></li>
<li><a href="#WyzDakzMFJDOlUux">Форматирование</a></li>
<li><a href="#IuEpFRcbaEZxQiKb">Комментарии</a></li>
<li><a href="#%D0%98%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Именование</a>
<ul>
<li><a href="#NZBEiZfHJwQgsgAq">Именование пакетов</a></li>
</ul>
</li>
<li><a href="#%D0%93%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B">Геттеры</a>
<ul>
<li><a href="#SewWWoIIVdWSQFGa">Имена интерфейсов</a></li>
<li><a href="#HQezgnOILtGuJxHj">MixedCaps</a></li>
<li><a href="#lwaaLvUQSWcgNrUG">Точка с запятой</a></li>
</ul>
</li>
<li><a href="#%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D1%8E%D1%89%D0%B8%D0%B5-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B">Управляющие структуры</a>
<ul>
<li><a href="#vwncZqAiNhUpQhVb">If</a></li>
<li><a href="#ruCVjWefoCoSHtsh">Переопределение и переприсваивание</a></li>
<li><a href="#ixLvsUaaMbotNOeJ">Оператор For</a></li>
<li><a href="#YVZlwAwnDOugKSHn">Switch(переключатель)</a></li>
<li><a href="#kWOQNJPZslRcwEcR">Переключатель типов (Типизированный переключатель, Type switch)</a></li>
</ul>
</li>
<li><a href="#%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%B8-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8Bfunctions-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B">Функции и методы(Functions, методы)</a>
<ul>
<li><a href="#hQuxOpeuQwpfPqdF">Множественное возвращение результатов</a></li>
<li><a href="#EztxFYNYPIVjwlSc">Именование параметров результата</a></li>
<li><a href="#mdIjbvBKkOGJyJKd">Отсроченный вызов (Defer)</a></li>
</ul>
</li>
<li><a href="#%D0%94%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5">Данные</a>
<ul>
<li><a href="#lcIzANjqvBJOstgz">Созданные с помощью new</a></li>
<li><a href="#heoIrbohJnCcMQjG">Конструкторы и составные литералы</a></li>
<li><a href="#QMwHFcoTFbVuNxnC">Создание с помощью make</a></li>
<li><a href="#nlAEXwboUtcScxjc">Массивы</a></li>
<li><a href="#xfbVtFBbGlVsjyxn">Срезы(Slices, слайсы)</a></li>
<li><a href="#kipNRySySuMazpzq">Двухмерные срезы</a></li>
<li><a href="#YXsabDdwubRKKeiw">Карты(Maps)</a></li>
<li><a href="#MKcrIgJNQYmbaYdX">Печать(Printing)</a></li>
<li><a href="#ZBNJtTNiQhWCyijm">Присоединение(Append)</a></li>
</ul>
</li>
<li><a href="#%D0%98%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8Finitialization">Инициализация(Initialization)</a>
<ul>
<li><a href="#fKNXnmDOUSNsmWpX">Константы(Constants)</a></li>
<li><a href="#wprodZIMlHjcrsGH">Переменные(Variables)</a></li>
<li><a href="#YUnDPbuAfwknQXpx">Функция init</a></li>
</ul>
</li>
<li><a href="#%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8Bmethods">Методы(Methods)</a>
<ul>
<li><a href="#AaUTRJqzrurdLTMo">Указатели или Значения</a></li>
</ul>
</li>
<li><a href="#%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B-%D0%B8-%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B">Интерфейсы и другие типы</a>
<ul>
<li><a href="#IkmWBdTuGSpgQpHd">Интерфейсы</a></li>
<li><a href="#lQqGQzrxNaARNDRE">Преобразование (Conversions)</a></li>
<li><a href="#SpGXsKpDQtgnSFId">Конвертация интерфейсов и привязка типов</a></li>
<li><a href="#DerBvtJJMYovnZaA">Общее(Generality)</a></li>
<li><a href="#gYdHydlVVHoKlSNP">Интерфейсы и методы(функции)</a></li>
</ul>
</li>
<li><a href="#%D0%9F%D1%83%D1%81%D1%82%D0%BE%D0%B9-%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80-the-blank-identifier-_">Пустой идентификатор (The blank identifier <strong>_</strong>)</a>
<ul>
<li><a href="#XWcYVsGQeWGiQmQE">Пустой идентификатор в множественном присваивании (<strong>_</strong>)</a></li>
<li><a href="#tsSblJgMIqXEGtPH">Неиспользуемое импортирование и значения</a></li>
<li><a href="#JIMLptPmQnacCavc">Импортирование для побочного эффекта (Import for side effect)</a></li>
<li><a href="#JfoeYvdhbieoxXXM">Проверка интерфейса (Interface checks)</a></li>
</ul>
</li>
<li><a href="#pnjCbYrZjJxCWpLd">Вложение (Embedding)</a></li>
<li><a href="#%D0%A1%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5--concurrency">Согласованность, параллельная обработка, параллельное выполнение  (Concurrency)</a>
<ul>
<li><a href="#DzEzXerMGDuYBwbJ">Распределение памяти по сообщениям (Share by communicating)</a></li>
<li><a href="#YQtRgjAiqfpVcmlU">Го-рутины (Goroutines)</a></li>
<li><a href="#OcdAMSYwbcqScwGd">Каналы (Channels)</a></li>
<li><a href="#VsPAwkhqLJAOplVM">Канал каналов (Channels of channels)</a></li>
<li><a href="#MnpoVhxOzInvuCqg">Параллелизм (Parallelization)</a></li>
<li><a href="#aWzGlHZYBYXlCyRO">Текущий буфер (A leaky buffer)</a></li>
</ul>
</li>
<li><a href="#%D0%9E%D1%88%D0%B8%D0%B1%D0%BA%D0%B8-errors">Ошибки (Errors)</a>
<ul>
<li><a href="#MIRrRXzUWETsmcJb">Паника (Panic)</a></li>
<li><a href="#rBrKsJLmdmQPsCIA">Восстановление (Recover)</a></li>
</ul>
</li>
<li><a href="#ADRNiLJuOnBDKhbB">Веб-сервер</a></li>
</ul>
<hr/>
<h2 id="SEmSMFZuEewLduBl">Введение</h2>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Go - это новый язык программирования. Хотя, он заимствует идеи из существующих языков, он обладает необычными свойствами, которые позволяют создавать эффективные программы, язык Go отличается по своему характеру от программ, написанных на родственных языках. Прямолинейный перевод C++ или Java программ в Go вряд ли даст удовлетворительный результат, т.к. Java программы написаны на Java, не на Go. С другой стороны, думая о проблеме с точки зрения Go можно добиться успеха, но это уже другая программа. Другими словами, для хорошего написания кода на языке Go, важно понимать его особенности и идиомы.<br/>
Также важно знать установленные соглашения для программирования на Go, такие как именование, форматирование, разработка программ и так далее, так чтобы программы написанные Вами были простыми для понимания другими программистами Go.</p>
<p>Этот документ даёт примеры для написания чистого, идеоматичного кода на Go.<br/>
Он дополняет <a href="https://golang.org/ref/spec" rel="nofollow">спецификацию языка</a>, <a href="https://tour.golang.org/" rel="nofollow">Тур по Go</a>,<br/>
и <a href="https://golang.org/doc/code.html" rel="nofollow">Как писать на Go</a>, каждую из которых необходимо прочитать в первую очередь.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="arhNVdJgdhXVLPJZ">Примеры</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p><a href="https://golang.org/src/" rel="nofollow">Go пакеты исходных кодов</a> предназначены не только в качестве основных библиотек, но и в качестве примеров использования языка.<br/>
Кроме того, многие пакеты имеют работающие, автономные исполняемые примеры и Вы можете запустить напрямую с помощью страницы <a href="https://golang.org" rel="nofollow">golang.org</a>, такие как <a href="https://golang.org/pkg/strings/#example_Map" rel="nofollow">этот</a> (если  необходимо, нажмите на слово &#34;Примеры&#34; чтобы открыть их).<br/>
Если у Вас есть вопрос о том как решить какую-либо проблему или как что-то реализовать, то документация, исходные коды и примеры в библиотеке могут дать ответ, идею или объяснение.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h2 id="WyzDakzMFJDOlUux">Форматирование</h2>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Форматирование является наиболее спорным, но не сильно важным вопросом.<br/>
Люди могут привыкнуть к различным стилям форматирования, но было бы лучше, если бы этого не приходилось делать и меньше времени придавалось этой теме, если бы все использовали одинаковый стиль.<br/>
Проблема данной утопии в том, как это сделать без длинного руководства по стилю.</p>
<p>В Go мы используем нетипичный подход и передаем машине заботу о форматировании.<br/>
Программа <code class="notranslate">gofmt</code> (также доступна, как <code class="notranslate">go fmt</code>, которая производит действия на уровне пакета, а не на уровне файлов) читает код на Go и выпускает исходный код со стандартным стилем отступов и вертикальным выравниванием, сохраняет, и при необходимости, переформатирует комментарии.<br/>
Если Вы хотите знать, как по-новому структурировать код, запустите <code class="notranslate">gofmt</code>; если структура неверна, <code class="notranslate">gofmt</code> поправит Вашу программу (или файл сообщит об ошибке <code class="notranslate">gofmt</code>), не работайте в обход форматирования программой <code class="notranslate">gofmt</code>.</p>
<p>К примеру, нет необходимости тратить время на выравнивание комментариев для полей структур, т.к. <code class="notranslate">gofmt</code> сделает это за Вас.<br/>
Для данного фрагмента кода</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">T</span> <span class="pl-k">struct</span> {
    <span class="pl-c1">name</span> <span class="pl-smi">string</span> <span class="pl-c">// name of the object</span>
    <span class="pl-c1">value</span> <span class="pl-smi">int</span> <span class="pl-c">// its value</span>
}</pre></div>
<p><code class="notranslate">gofmt</code> произведет выравнивание по колонкам:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">T</span> <span class="pl-k">struct</span> {
    <span class="pl-c1">name</span>    <span class="pl-smi">string</span> <span class="pl-c">// name of the object</span>
    <span class="pl-c1">value</span>   <span class="pl-smi">int</span>    <span class="pl-c">// its value</span>
}</pre></div>
<p>Все стандартные пакеты Go отформатированы с помощью <code class="notranslate">gofmt</code>.</p>
<p>Очень коротко о некоторых деталях форматирования:</p>
<h4 id="pwFksYfjOlzpngHZ">Абзац</h4>
<p>Мы используем табуляцию для абзацев и <code class="notranslate">gofmt</code> делает это по умолчанию. Используйте пробелы только при острой необходимости.</p>
<h4 id="fMOPOdjIuLpAnDPf">Длина строки</h4>
<p>Go не имеет предела длины строки. Не беспокойтесь о длинных строках. Если строка кажется слишком длинной, прервите ее и добавьте дополнительный отступ (символ табуляции) на новой строке.</p>
<h4 id="RJXGqflCHjxYproq">Круглые скобки</h4>
<p>Go нуждается в меньшем количестве круглых скобок, чем C и Java: структуры ветвления, цикла ( <code class="notranslate">if</code> , <code class="notranslate">for</code> , <code class="notranslate">switch</code>) не имеют круглых скобок в своём синтаксисе. Также, иерархия операторов стала проще и короче. К примеру, выражение</p>
<pre class="notranslate"><code class="notranslate">x&lt;&lt;8 + y&lt;&lt;16
</code></pre>
<p>не нуждается в добавлении пробелов, в отличии от других языков.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h2 id="IuEpFRcbaEZxQiKb">Комментарии</h2>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Go использует C-стиль <code class="notranslate">/* */</code> для блока комментариев и C++-стиль <code class="notranslate">//</code> для однострочных комментариев.<br/>
Как правило, используются однострочные комментарии. Блок комментариев, в основном, используется при комментировании пакетов,<br/>
но также для выразительности или отключения большого участка кода.</p>
<p>Программа и веб-сервер - <code class="notranslate">godoc</code> обрабатывает Go исходники пакета для формирования документации.<br/>
Комментарии, расположенные сразу над объявлением (без дополнительных пустых строк), извлекаются вместе с объявлением для пояснения данного элемента.<br/>
Характер и стиль комментариев напрямую влияет на качество документации производимой <code class="notranslate">godoc</code>.</p>
<p>Каждый пакет должен иметь <em>комментарий пакета</em> - это блок комментариев предшествующий объявлению пакета.<br/>
Для пакетов состоящих из нескольких файлов, комментарий пакета может быть расположен в любом из файлов, но только в одном из них.<br/>
Комментарий пакета должен представлять информацию о пакете в целом.<br/>
Он будет отображен вначале страницы <code class="notranslate">godoc</code> и должен представлять из себя детальную информацию, которой можно пользоваться.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">/*</span>
<span class="pl-c">Package regexp implements a simple library for regular expressions.</span>
<span class="pl-c"></span>
<span class="pl-c">The syntax of the regular expressions accepted is:</span>
<span class="pl-c"></span>
<span class="pl-c">    regexp:</span>
<span class="pl-c">        concatenation { &#39;|&#39; concatenation }</span>
<span class="pl-c">    concatenation:</span>
<span class="pl-c">        { closure }</span>
<span class="pl-c">    closure:</span>
<span class="pl-c">        term [ &#39;*&#39; | &#39;+&#39; | &#39;?&#39; ]</span>
<span class="pl-c">    term:</span>
<span class="pl-c">        &#39;^&#39;</span>
<span class="pl-c">        &#39;$&#39;</span>
<span class="pl-c">        &#39;.&#39;</span>
<span class="pl-c">        character</span>
<span class="pl-c">        &#39;[&#39; [ &#39;^&#39; ] character-ranges &#39;]&#39;</span>
<span class="pl-c">        &#39;(&#39; regexp &#39;)&#39;</span>
<span class="pl-c">*/</span>
<span class="pl-k">package</span> regexp</pre></div>
<p>Если пакет простой, то комментарий может быть кратким.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// Package path implements utility routines for</span>
<span class="pl-c">// manipulating slash-separated filename paths.</span></pre></div>
<p>Дополнительное форматирование, к примеру баннер из * (звездочек), не требуется.<br/>
Шрифт для сформированного результата не обязательно будет моноширинный, поэтому не полагайтесь на пробелы при выравнивании, <code class="notranslate">godoc</code>, также как <code class="notranslate">gofmt</code>, позаботятся об этом.<br/>
Комментарии интерпретируются как простой текст, поэтому HTML и другие аннотации такие как <code class="notranslate">_эта_</code> воспроизводятся <em>дословно</em> и поэтому не должны использоваться. Единственное исключение,<br/>
которое делает <code class="notranslate">godoc</code>, это выделение моноширинным шрифтом участков кода с отступами.<br/>
Хорошим примером такого исключения является комментарий к пакету <a href="https://golang.org/pkg/fmt/" rel="nofollow"><code class="notranslate">fmt</code></a>.</p>
<p>В зависимости от контекста, <code class="notranslate">godoc</code> не может переформатировать комментарии, поэтому убедитесь, что они выглядят хорошо: используйте правильное правописание, знаки препинания, структуру предложения и т.д.</p>
<p>Любые комментарии внутри пакета, предшествующие объявлению, используются как описание этого объявления.<br/>
Каждый экспортируемый объект, название которого начинается с большой буквы, должен иметь комментарий.</p>
<p>Лучше всего использовать комментарии в виде полных предложений. Это позволяет производить их автоматическую обработку.<br/>
Первое предложение должно быть ключевым и начинаться с имени объявления.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// Compile parses a regular expression and returns, if successful,</span>
<span class="pl-c">// a Regexp that can be used to match against text.</span>
<span class="pl-k">func</span> <span class="pl-en">Compile</span>(<span class="pl-s1">str</span> <span class="pl-smi">string</span>) (<span class="pl-c1">*</span><span class="pl-smi">Regexp</span>, <span class="pl-smi">error</span>) {</pre></div>
<p>Если комментарий начинается с имени, то <code class="notranslate">godoc</code> может с использоваться совместно с <code class="notranslate">grep</code>.<br/>
Представьте, что Вы не можете вспомнить имя &#34;Compile&#34;, но Вы ищите <em>the parsing function</em> для регулярных выражений и тогда Вы можете выполнить команду:</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">$ godoc regexp <span class="pl-k">|</span> grep -i parse</pre></div>
<p>Если все комментарии в пакете начинаются с &#34;This function...&#34;, <code class="notranslate">grep</code> не сможет помочь с поиском имени.<br/>
Если же комментарии  начинаются с имени, Вы можете увидеть что-то вроде следующего результата, который напомнит Вам о том, что Вы искали.</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">$ godoc regexp <span class="pl-k">|</span> grep parse
    Compile parses a regular expression and returns, <span class="pl-k">if</span> successful, a Regexp
    parsed. It simplifies safe initialization of global variables holding
    cannot be parsed. It simplifies safe initialization of global variables
$</pre></div>
<p>Синтаксис Go допускает групповое объявление. Для каждой группы констант или переменных может быть представлен один общий комментарий. Однако такое объявление выглядит небрежно.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// Error codes returned by failures to parse an expression.</span>
<span class="pl-k">var</span> (
    <span class="pl-s1">ErrInternal</span>      <span class="pl-c1">=</span> <span class="pl-s1">errors</span>.<span class="pl-en">New</span>(<span class="pl-s">&#34;regexp: internal error&#34;</span>)
    <span class="pl-s1">ErrUnmatchedLpar</span> <span class="pl-c1">=</span> <span class="pl-s1">errors</span>.<span class="pl-en">New</span>(<span class="pl-s">&#34;regexp: unmatched &#39;(&#39;&#34;</span>)
    <span class="pl-s1">ErrUnmatchedRpar</span> <span class="pl-c1">=</span> <span class="pl-s1">errors</span>.<span class="pl-en">New</span>(<span class="pl-s">&#34;regexp: unmatched &#39;)&#39;&#34;</span>)
    <span class="pl-c1">...</span>
)</pre></div>
<p>Группировка также может показать взаимосвязи между элементами, к примеру, группа переменных защищенных mutex:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">var</span> (
    <span class="pl-s1">countLock</span>   sync.<span class="pl-smi">Mutex</span>
    <span class="pl-s1">inputCount</span>  <span class="pl-smi">uint32</span>
    <span class="pl-s1">outputCount</span> <span class="pl-smi">uint32</span>
    <span class="pl-s1">errorCount</span>  <span class="pl-smi">uint32</span>
)</pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h2 id="JMXAEeSMKFvvIDrD">Именование</h2>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Именование очень важно в Go, как и в других языках.<br/>
Они имеют семантический эффект: <strong>Видимость имени за пределами пакета, определяется по первой букве имени, которая, если является заглавной, то имя будет видно вне это пакета</strong>.<br/>
Именно поэтому стоит уделить время обсуждению соглашения об именовании в программах Go.</p>
<h3 id="NZBEiZfHJwQgsgAq">Именование пакетов</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Когда пакет импортируется, имя пакета используется для доступа к его содержимому.<br/>
После того, как пакет импортирован,</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-s">&#34;bytes&#34;</span></pre></div>
<p>можно использовать <code class="notranslate">bytes.Buffer</code>. Это полезно, если все, кто использует пакет, могут использовать одно и то же имя, для обращения к его содержимому, подразумевается, что имя пакета должно быть коротким, четким и запоминающимся. В соответствии с соглашением,имена пакетов состоят из одного слова в нижнем регистре; нет необходимости в использовании подчеркиваний или СмешанногоРегистра. При выборе длинного имени пакета, всем, кто будет его использовать, придётся писать это имя. Но не беспокойтесь об уникальности имени.<br/>
Имя пакета только по умолчанию используется при импорте; оно не должно быть глобально уникальным, и в редких случаях, при импорте может быть указано другое имя. В любом случае,<br/>
путаница встречается редко, так как имя файла в импорте определяет, какой именно пакет используется.</p>
<p>Согласно другому соглашению, имя пакета является базовым именем его исходного каталога; пакет <code class="notranslate">src/encoding/base64</code> импортируется как <code class="notranslate">&#34;encoding/base64&#34;</code> и имеет название <code class="notranslate">base64</code>, а не <code class="notranslate">encoding_base64</code> и не <code class="notranslate">encodingBase64</code>.</p>
<p>Импортирующий пакет будет использовать имя пакета для обозначения его содержимого, поэтому при экспорте может учитываться этот факт, чтобы избежать повторения.<br/>
(Не используйте <code class="notranslate">import .</code>, это, конечно, может упростить запуск тестов вне пакета, но в других случаях использоваться не должно). Например, тип <em>reader</em> для буферного чтения описанный в пакете <code class="notranslate">bufio</code> называется <code class="notranslate">Reader</code>, а не <code class="notranslate">BufReader</code>, т.к пользователи его видят как <code class="notranslate">bufio.Reader</code>, имя которого кратко и понятно.</p>
<p>Более того, т.к. импортируемые объекты адресуются по имени пакета, следовательно <code class="notranslate">bufio.Reader</code> не будет конфликтовать с <code class="notranslate">io.Reader</code>.<br/>
Аналогично, функция для создания нового экземпляра объекта <code class="notranslate">ring.Ring</code>, которая объявлена как <em>конструктор</em> в Go, может называться <code class="notranslate">NewRing</code>, но т.к. <code class="notranslate">Ring</code> - это экспортируемый тип из пакета <code class="notranslate">ring</code>, функция-конструктор может называться просто <code class="notranslate">New</code>, которую, можно будет вызвать как <code class="notranslate">ring.New</code>. Используйте структуру пакетов при<br/>
выборе имен.</p>
<p>Другой короткий пример функция <code class="notranslate">once.Do</code>; <code class="notranslate">once.Do(setup)</code> читается хорошо, и при этом<br/>
лучше не станет, если ее переименовать в <code class="notranslate">once.DoOrWaitUntilDone(setup)</code>.<br/>
Длинные имена не делают названия более читабельными. В то время как комментарии<br/>
могут быть более ценным, чем длинные имена.</p>
<h2 id="SOfGqAAKgDtNxKPA">Геттеры</h2>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Go не предоставляет автоматическую поддержку геттеров и сеттеров.<br/>
Но не будет ошибкой создание геттеров и сеттеров самостоятельно, и если это необходимо, то делайте так, но идиоматически нет необходимости добавлять <code class="notranslate">Get</code> в имя геттера.<br/>
Если у Вас есть поле с именем <code class="notranslate">owner</code> (с маленькой буквы, неэкспортируемое), то геттер может называться <code class="notranslate">Owner</code> (с большой буквы, экспортируемый), а не <code class="notranslate">GetOwner</code>.<br/>
Использование имен, начинающихся с заглавной буквы, позволяет отделить экспортируемые методы от неэкспортируемых полей. Cеттер, при необходимости, может быть назван <code class="notranslate">SetOwner</code>.<br/>
Оба примера в следующем коде:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">owner</span> <span class="pl-c1">:=</span> <span class="pl-s1">obj</span>.<span class="pl-en">Owner</span>()
<span class="pl-k">if</span> <span class="pl-s1">owner</span> <span class="pl-c1">!=</span> <span class="pl-s1">user</span> {
    <span class="pl-s1">obj</span>.<span class="pl-en">SetOwner</span>(<span class="pl-s1">user</span>)
}</pre></div>
<h3 id="SewWWoIIVdWSQFGa">Имена интерфейсов</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>По соглашению, интерфейсы с одним методом должны называться как метод с суффиксом <code class="notranslate">-er</code> или подобно этому,  для образования существительного: <code class="notranslate">Reader</code>, <code class="notranslate">Writer</code>, <code class="notranslate">Formatter</code>, <code class="notranslate">CloseNotifier</code> и т.д.</p>
<p>Существует целый ряд имен, которыe соблюдают это соглашение и содержат подобные методы. <code class="notranslate">Read</code> , <code class="notranslate">Write</code> , <code class="notranslate">Close</code>, <code class="notranslate">Flush</code>, <code class="notranslate">String</code> и т.д., имеют канонические подписи и значения. Чтобы избежать путаницы, не давайте методу ни одного из этих имен, если оно не имеет ту же сигнатуру и значение. С другой стороны, если ваш тип реализует метод с тем же значением, как и метод хорошо известного типа, то дайте ему то же имя и значение; назовите Ваш метод конвертации в строку <code class="notranslate">String</code> , а не <code class="notranslate">ToString</code>.</p>
<h3 id="HQezgnOILtGuJxHj">MixedCaps</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>В заключении, Go соглашение использует <code class="notranslate">MixedCaps</code> или <code class="notranslate">mixedCaps</code> , а не подчеркивание для имен из нескольких слов.</p>
<h3 id="lwaaLvUQSWcgNrUG">Точка с запятой</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Как и в С, грамматика Go формально использует точку с запятой для разделения<br/>
операций-выражений (инструкций), но в отличии от C, точка с запятой не представлена<br/>
в исходном коде. Вместо этого, лексер использует простое правило добавления<br/>
точки с запятой автоматически, при сканировани. Таким образом текст на входе<br/>
по большей части освобожден от них.</p>
<p>Правило такое. Если последний токен(лексема) перед символом новой строки - идентификатор (который включает такие слова, как <code class="notranslate">int</code> и <code class="notranslate">float64</code>), базовый литерал, такой как число или строковая константа, или один из нижеперечисленных токенов</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">break</span> continue <span class="pl-s1">fallthrough</span> <span class="pl-k">return</span> <span class="pl-c1">+</span><span class="pl-c1">+</span> <span class="pl-c1">-</span><span class="pl-c1">-</span> ) }</pre></div>
<p>то, лексер всегда добавляет точку с запятой после него. Вкратце, это может звучать так: &#34;Если новая строка начинается после токена, который может закрывать операцию-выражение,  то добавить точку с запятой&#34;.</p>
<p>Точка с запятой также может быть опущена сразу перед закрывающей скобкой, таким<br/>
образом для операции-выражения такой как:</p>
<div class="highlight highlight-source-go"><pre class="notranslate">     <span class="pl-k">go</span> <span class="pl-k">func</span>() { <span class="pl-k">for</span> { <span class="pl-s1">dst</span> <span class="pl-c1">&lt;-</span> <span class="pl-c1">&lt;-</span><span class="pl-s1">src</span> } }()</pre></div>
<p>точка с запятой не требуется.</p>
<p>Как следствие из правила, вы не можете перенести открывающую скобку управляющих<br/>
структур (<code class="notranslate">if</code>, <code class="notranslate">for</code>, <code class="notranslate">switch</code> или <code class="notranslate">select</code>) на новую строку. Если перенесете,<br/>
точка с запятой будет вставлена перед скобкой, которая может стать причиной<br/>
нежелательных эффектов. Пишите так,</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">if</span> <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-en">f</span>() {
    <span class="pl-en">g</span>()
}</pre></div>
<p>но не так</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">if</span> <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-en">f</span>()  <span class="pl-c">// ошибка!</span>
{           <span class="pl-c">// ошибка!</span>
    <span class="pl-en">g</span>()
}</pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h2 id="gYhhDuOYZuTKYxdu">Управляющие структуры</h2>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Управляющие структуры в Go аналогичны тем же структурам в C, но имеют ряд важных отличий. Во-первых нет циклов <code class="notranslate">do</code> и <code class="notranslate">while</code>, есть лишь обобщенный <code class="notranslate">for</code>. Во-вторых, <code class="notranslate">switch</code> более гибкий. В-третьих <code class="notranslate">if</code> и <code class="notranslate">switch</code> имеют опциональную инициализацию переменных, как и в <code class="notranslate">for</code>. В-четвертых, <code class="notranslate">break</code> и <code class="notranslate">continue</code> опционально принимают метку, к которой необходимо перейти. В-пятых, есть новые операторы, такие как типизированный <code class="notranslate">switch</code> и многоканальный <code class="notranslate">select</code>. Синтаксис также немного отличается: отсутствуют круглые скобки в условии, и тело структуры всегда должно быть ограничено фигурными скобками.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="vwncZqAiNhUpQhVb">If</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>В Go простой <code class="notranslate">if</code> выглядит так:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">if</span> <span class="pl-s1">x</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">0</span> {
    <span class="pl-k">return</span> <span class="pl-s1">y</span>
}</pre></div>
<p>Обязательные фигурные скобки упрощают написание простых условий <code class="notranslate">if</code> на<br/>
несколько строк. Это хороший стиль в любом случае, особенно когда тело содержит управляющие операторы, такие как <code class="notranslate">return</code> или <code class="notranslate">break</code>.</p>
<p>Поскольку <code class="notranslate">if</code> и <code class="notranslate">switch</code> допускают инициализацию переменных, то часто можно<br/>
видеть подобную запись:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">if</span> <span class="pl-s1">err</span> <span class="pl-c1">:=</span> <span class="pl-s1">file</span>.<span class="pl-en">Chmod</span>(<span class="pl-c1">0664</span>); <span class="pl-s1">err</span> <span class="pl-c1">!=</span> <span class="pl-c1">nil</span> {
    <span class="pl-s1">log</span>.<span class="pl-en">Print</span>(<span class="pl-s1">err</span>)
    <span class="pl-k">return</span> <span class="pl-s1">err</span>
}</pre></div>
<p>В библиотеках Go, вы найдёте подобную запись, если <code class="notranslate">if</code> не переходит в следующий блок, т.е. в теле используется <code class="notranslate">break</code>, <code class="notranslate">continue</code>, <code class="notranslate">goto</code> или <code class="notranslate">return</code>, а необязательный <code class="notranslate">else</code> опускается.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">f</span>, <span class="pl-s1">err</span> <span class="pl-c1">:=</span> <span class="pl-s1">os</span>.<span class="pl-en">Open</span>(<span class="pl-s1">name</span>)
<span class="pl-k">if</span> <span class="pl-s1">err</span> <span class="pl-c1">!=</span> <span class="pl-c1">nil</span> {
    <span class="pl-k">return</span> <span class="pl-s1">err</span>
}
<span class="pl-en">codeUsing</span>(<span class="pl-s1">f</span>)</pre></div>
<p>В данном примере представлена общая схема, где код защищен от серии ошибок. Код читается хорошо, если выполняется без ошибок, обходя случаи их возникновения. Так как ошибки приводят к завершению выполнения блока с помощью <code class="notranslate">return</code>, то блок <code class="notranslate">else</code> не требуется.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">f</span>, <span class="pl-s1">err</span> <span class="pl-c1">:=</span> <span class="pl-s1">os</span>.<span class="pl-en">Open</span>(<span class="pl-s1">name</span>)
<span class="pl-k">if</span> <span class="pl-s1">err</span> <span class="pl-c1">!=</span> <span class="pl-c1">nil</span> {
    <span class="pl-k">return</span> <span class="pl-s1">err</span>
}
<span class="pl-s1">d</span>, <span class="pl-s1">err</span> <span class="pl-c1">:=</span> <span class="pl-s1">f</span>.<span class="pl-en">Stat</span>()
<span class="pl-k">if</span> <span class="pl-s1">err</span> <span class="pl-c1">!=</span> <span class="pl-c1">nil</span> {
    <span class="pl-s1">f</span>.<span class="pl-en">Close</span>()
    <span class="pl-k">return</span> <span class="pl-s1">err</span>
}
<span class="pl-en">codeUsing</span>(<span class="pl-s1">f</span>, <span class="pl-s1">d</span>)</pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="ruCVjWefoCoSHtsh">Переопределение и переприсваивание</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Последний пример предыдущего раздела демонстрирует использование краткой формы объявления переменных <code class="notranslate">:=</code>. Вызов <code class="notranslate">os.Open</code> объявляет сразу две переменных <code class="notranslate">f</code> и <code class="notranslate">err</code></p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">f</span>, <span class="pl-s1">err</span> <span class="pl-c1">:=</span> <span class="pl-s1">os</span>.<span class="pl-en">Open</span>(<span class="pl-s1">name</span>)</pre></div>
<p>Несколькими строками ниже вызывается <code class="notranslate">f.Stat</code>,</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">d</span>, <span class="pl-s1">err</span> <span class="pl-c1">:=</span> <span class="pl-s1">f</span>.<span class="pl-en">Stat</span>()</pre></div>
<p>который выглядит как объявления двух переменных <code class="notranslate">d</code> и <code class="notranslate">err</code>. Хотя <code class="notranslate">err</code> присутствует в обоих объявлениях. Это дублирование вполне законно: <code class="notranslate">err</code> объявляется в первом случае, и лишь переприсваивается во втором. Это означает, что <code class="notranslate">f.Stat</code> использует уже существующую переменную <code class="notranslate">err</code>, определенную выше, и просто присваивает ей новое значение.</p>
<p>В объявлении <code class="notranslate">:=</code> переменная <code class="notranslate">v</code> может присутствовать, даже если она уже объявлена, при условии:</p>
<ul>
<li>если объявление происходит в той же самой области видимости, что и существующая переменная <code class="notranslate">v</code> (если <code class="notranslate">v</code> уже объявлена за пределами видимости, то объявление создаст новую переменную §)</li>
<li>соответствующее значение, при инициализации, может быть присвоено <code class="notranslate">v</code></li>
<li>существует хотя бы одна новая переменная в объявлении, которая будет создана заново</li>
</ul>
<p>Это необычное свойство - чистая практичность, которая служит для упрощения<br/>
использования одной переменной <code class="notranslate">err</code>, к примеру, в длинных цепочках <code class="notranslate">if-else</code>.<br/>
Вы увидите, это используется часто.</p>
<p>§ Нет ничего плохого в том, что в Go область видимости параметров и возвращаемых значений функции - есть само тело функции, хотя они лексически находятся за скобками, ограничивающими тело функции.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="ixLvsUaaMbotNOeJ">Оператор For</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>В Go цикл <code class="notranslate">for</code> очень похож, но не такой же как в C. Он унифицирует <code class="notranslate">for</code> и <code class="notranslate">while</code>, при этом отсутствует <code class="notranslate">do-while</code> цикл. Существует 3 различных формы, и только в одной из них используется точка с запятой.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// C-подобный for</span>
<span class="pl-k">for</span> <span class="pl-s1">init</span>; <span class="pl-s1">condition</span>; <span class="pl-s1">post</span> { }

<span class="pl-c">// C-подобный while</span>
<span class="pl-k">for</span> <span class="pl-s1">condition</span> { }

<span class="pl-c">// C-подобный for(;;)</span>
<span class="pl-k">for</span> { }</pre></div>
<p>Краткая запись позволяет легко объявить начальные условия прямо в цикле:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">sum</span> <span class="pl-c1">:=</span> <span class="pl-c1">0</span>
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">:=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">10</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span> {
    <span class="pl-s1">sum</span> <span class="pl-c1">+=</span> <span class="pl-s1">i</span>
}</pre></div>
<p>Если Вы итерируетесь по массиву, срезу, строке или map&#39;у, или читаете из канала, то для управления можно использовать <code class="notranslate">range</code>.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">for</span> <span class="pl-s1">key</span>, <span class="pl-s1">value</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-s1">oldMap</span> {
    <span class="pl-s1">newMap</span>[<span class="pl-s1">key</span>] <span class="pl-c1">=</span> <span class="pl-s1">value</span>
}</pre></div>
<p>Если необходимо использовать только первый элемент <em>диапазона</em> (ключ или индекс), отбросьте второй:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">for</span> <span class="pl-s1">key</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-s1">m</span> {
    <span class="pl-k">if</span> <span class="pl-s1">key</span>.<span class="pl-en">expired</span>() {
        <span class="pl-en">delete</span>(<span class="pl-s1">m</span>, <span class="pl-s1">key</span>)
    }
}</pre></div>
<p>Если вам необходим только второй элемент (значение), то используйте <em>пустой идентификатор</em> (<strong>_</strong>) в качестве первого элемента:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">sum</span> <span class="pl-c1">:=</span> <span class="pl-c1">0</span>
<span class="pl-k">for</span> <span class="pl-s1">_</span> , <span class="pl-s1">value</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-s1">array</span> {
    <span class="pl-s1">sum</span> <span class="pl-c1">+=</span> <span class="pl-s1">value</span>
}</pre></div>
<p>Пустой идентификатор используется в разных случаях и будет описан позже.</p>
<p>Для строк, оператор <code class="notranslate">range</code> выполняет ещё больше работы, к примеру разделяет строку по символам Unicode в соответствии с UTF-8. При ошибочном использование кодировки, побайтово заменяет рунами(<em>rune</em>) U+FFFD. (<code class="notranslate">rune</code> (и одноименный встроенный тип) в терминологии Go используется для работы с символами Unicode. Смотрите детальную информацию в <a href="https://golang.org/ref/spec#Rune_literals" rel="nofollow">Спецификации языка</a>).</p>
<p>Данный цикл:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">for</span> <span class="pl-s1">pos</span>, <span class="pl-s1">char</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-s">&#34;日本<span class="pl-cce">\x80</span>語&#34;</span> { <span class="pl-c">// \x80 is an illegal UTF-8 encoding</span>
    <span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;character %#U starts at byte position %d<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">char</span>, <span class="pl-s1">pos</span>)
}</pre></div>
<p>Выводит:</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">character U+65E5 <span class="pl-s"><span class="pl-pds">&#39;</span>日<span class="pl-pds">&#39;</span></span> starts at byte position 0
character U+672C <span class="pl-s"><span class="pl-pds">&#39;</span>本<span class="pl-pds">&#39;</span></span> starts at byte position 3
character U+FFFD <span class="pl-s"><span class="pl-pds">&#39;</span>�<span class="pl-pds">&#39;</span></span> starts at byte position 6
character U+8A9E <span class="pl-s"><span class="pl-pds">&#39;</span>語<span class="pl-pds">&#39;</span></span> starts at byte position 7</pre></div>
<p>И в заключении, в языке Go нет оператора <code class="notranslate">запятая</code>, а <code class="notranslate">++</code> и <code class="notranslate">--</code> являются инструкциями, но не выражениями. Таким образом, если Вам необходимо использовать несколько переменных в цикле <code class="notranslate">for</code>, то Вы можете использовать параллельное определение переменных (без использования <code class="notranslate">++</code> и <code class="notranslate">--</code>).</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// Reverse a</span>
<span class="pl-k">for</span> <span class="pl-s1">i</span>, <span class="pl-s1">j</span> <span class="pl-c1">:=</span> <span class="pl-c1">0</span>, <span class="pl-en">len</span>(<span class="pl-s1">a</span>)<span class="pl-c1">-</span><span class="pl-c1">1</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">j</span>; <span class="pl-s1">i</span>, <span class="pl-s1">j</span> <span class="pl-c1">=</span> <span class="pl-s1">i</span><span class="pl-c1">+</span><span class="pl-c1">1</span>, <span class="pl-s1">j</span><span class="pl-c1">-</span><span class="pl-c1">1</span> {
    <span class="pl-s1">a</span>[<span class="pl-s1">i</span>], <span class="pl-s1">a</span>[<span class="pl-s1">j</span>] <span class="pl-c1">=</span> <span class="pl-s1">a</span>[<span class="pl-s1">j</span>], <span class="pl-s1">a</span>[<span class="pl-s1">i</span>]
}</pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="YVZlwAwnDOugKSHn">Switch(переключатель)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>В языке Go <code class="notranslate">switch</code> более обобщён, нежели в C. Выражения не обязательно должны<br/>
быть константами или даже целыми числами, условия проверяются сверху-вниз до нахождения соответствия, и если <code class="notranslate">switch</code> не имеет выражений, то переходит в <code class="notranslate">true</code>. Следовательно, идиоматически возможно записывать <code class="notranslate">if-else-if-else</code> цепочку как <code class="notranslate">switch</code>.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">unhex</span>(<span class="pl-s1">c</span> <span class="pl-smi">byte</span>) <span class="pl-smi">byte</span> {
    <span class="pl-k">switch</span> {
    <span class="pl-k">case</span> <span class="pl-s">&#39;0&#39;</span> <span class="pl-c1">&lt;=</span> <span class="pl-s1">c</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-s1">c</span> <span class="pl-c1">&lt;=</span> <span class="pl-s">&#39;9&#39;</span>:
        <span class="pl-k">return</span> <span class="pl-s1">c</span> <span class="pl-c1">-</span> <span class="pl-s">&#39;0&#39;</span>
    <span class="pl-k">case</span> <span class="pl-s">&#39;a&#39;</span> <span class="pl-c1">&lt;=</span> <span class="pl-s1">c</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-s1">c</span> <span class="pl-c1">&lt;=</span> <span class="pl-s">&#39;f&#39;</span>:
        <span class="pl-k">return</span> <span class="pl-s1">c</span> <span class="pl-c1">-</span> <span class="pl-s">&#39;a&#39;</span> <span class="pl-c1">+</span> <span class="pl-c1">10</span>
    <span class="pl-k">case</span> <span class="pl-s">&#39;A&#39;</span> <span class="pl-c1">&lt;=</span> <span class="pl-s1">c</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-s1">c</span> <span class="pl-c1">&lt;=</span> <span class="pl-s">&#39;F&#39;</span>:
        <span class="pl-k">return</span> <span class="pl-s1">c</span> <span class="pl-c1">-</span> <span class="pl-s">&#39;A&#39;</span> <span class="pl-c1">+</span> <span class="pl-c1">10</span>
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>
}</pre></div>
<p>Автоматический пропуск условий отсутствует, но, при этом, условия могут быть записаны через запятую:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">shouldEscape</span>(<span class="pl-s1">c</span> <span class="pl-smi">byte</span>) <span class="pl-smi">bool</span> {
    <span class="pl-k">switch</span> <span class="pl-s1">c</span> {
    <span class="pl-k">case</span> <span class="pl-s">&#39; &#39;</span>, <span class="pl-s">&#39;?&#39;</span>, <span class="pl-s">&#39;&amp;&#39;</span>, <span class="pl-s">&#39;=&#39;</span>, <span class="pl-s">&#39;#&#39;</span>, <span class="pl-s">&#39;+&#39;</span>, <span class="pl-s">&#39;%&#39;</span>:
        <span class="pl-k">return</span> <span class="pl-c1">true</span>
    }
    <span class="pl-k">return</span> <span class="pl-c1">false</span>
}</pre></div>
<p>Несмотря на то, что они не столь распространены в Go, как в некоторых других C-подобных языках, <code class="notranslate">break</code> может быть использован для досрочного прерывания <code class="notranslate">switch</code>.<br/>
Хотя, иногда, надо прервать внешний (по отношению к <code class="notranslate">switch</code>) цикл, а не сам <code class="notranslate">switch</code>, и в Go это может быть достигнуто путём добавления метки перед циклом, и переходом к этой метке в случае вызова <code class="notranslate">break</code>. В следующем примере представлены оба случая:</p>
<div class="highlight highlight-source-go"><pre class="notranslate">Loop:
	<span class="pl-k">for</span> <span class="pl-s1">n</span> <span class="pl-c1">:=</span> <span class="pl-c1">0</span>; <span class="pl-s1">n</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">src</span>); <span class="pl-s1">n</span> <span class="pl-c1">+=</span> <span class="pl-s1">size</span> {
		<span class="pl-k">switch</span> {
		<span class="pl-k">case</span> <span class="pl-s1">src</span>[<span class="pl-s1">n</span>] <span class="pl-c1">&lt;</span> <span class="pl-s1">sizeOne</span>:
			<span class="pl-k">if</span> <span class="pl-s1">validateOnly</span> {
				<span class="pl-k">break</span>
			}
			<span class="pl-s1">size</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span>
			<span class="pl-en">update</span>(<span class="pl-s1">src</span>[<span class="pl-s1">n</span>])

		<span class="pl-k">case</span> <span class="pl-s1">src</span>[<span class="pl-s1">n</span>] <span class="pl-c1">&lt;</span> <span class="pl-s1">sizeTwo</span>:
			<span class="pl-k">if</span> <span class="pl-s1">n</span><span class="pl-c1">+</span><span class="pl-c1">1</span> <span class="pl-c1">&gt;=</span> <span class="pl-en">len</span>(<span class="pl-s1">src</span>) {
				<span class="pl-s1">err</span> <span class="pl-c1">=</span> <span class="pl-s1">errShortInput</span>
				<span class="pl-k">break</span> Loop
			}
			<span class="pl-k">if</span> <span class="pl-s1">validateOnly</span> {
				<span class="pl-k">break</span>
			}
			<span class="pl-s1">size</span> <span class="pl-c1">=</span> <span class="pl-c1">2</span>
			<span class="pl-en">update</span>(<span class="pl-s1">src</span>[<span class="pl-s1">n</span>] <span class="pl-c1">+</span> <span class="pl-s1">src</span>[<span class="pl-s1">n</span><span class="pl-c1">+</span><span class="pl-c1">1</span>]<span class="pl-c1">&lt;&lt;</span><span class="pl-s1">shift</span>)
		}
	}</pre></div>
<p>Конечно, <code class="notranslate">continue</code> также допускает использование меток, но только в циклах.</p>
<p>В заключении, метод сравнения байтовых срезов использующий два оператора <code class="notranslate">switch</code>:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// Compare returns an integer comparing the two byte slices,</span>
<span class="pl-c">// lexicographically.</span>
<span class="pl-c">// The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b</span>
<span class="pl-k">func</span> <span class="pl-en">Compare</span>(<span class="pl-s1">a</span>, <span class="pl-s1">b</span> []<span class="pl-smi">byte</span>) <span class="pl-smi">int</span> {
    <span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">:=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">a</span>) <span class="pl-c1">&amp;&amp;</span> <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">b</span>); <span class="pl-s1">i</span><span class="pl-c1">++</span> {
        <span class="pl-k">switch</span> {
        <span class="pl-k">case</span> <span class="pl-s1">a</span>[<span class="pl-s1">i</span>] <span class="pl-c1">&gt;</span> <span class="pl-s1">b</span>[<span class="pl-s1">i</span>]:
            <span class="pl-k">return</span> <span class="pl-c1">1</span>
        <span class="pl-k">case</span> <span class="pl-s1">a</span>[<span class="pl-s1">i</span>] <span class="pl-c1">&lt;</span> <span class="pl-s1">b</span>[<span class="pl-s1">i</span>]:
            <span class="pl-k">return</span> <span class="pl-c1">-</span><span class="pl-c1">1</span>
        }
    }
    <span class="pl-k">switch</span> {
    <span class="pl-k">case</span> <span class="pl-en">len</span>(<span class="pl-s1">a</span>) <span class="pl-c1">&gt;</span> <span class="pl-en">len</span>(<span class="pl-s1">b</span>):
        <span class="pl-k">return</span> <span class="pl-c1">1</span>
    <span class="pl-k">case</span> <span class="pl-en">len</span>(<span class="pl-s1">a</span>) <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">b</span>):
        <span class="pl-k">return</span> <span class="pl-c1">-</span><span class="pl-c1">1</span>
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>
}</pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="kWOQNJPZslRcwEcR">Переключатель типов (Типизированный переключатель, Type switch)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p><code class="notranslate">switch</code> может быть использован для определения динамических типов интерфейсных переменных. Так, типизированный <code class="notranslate">switch</code> использует синтаксис приведения типов,<br/>
с ключевым словом <code class="notranslate">type</code> внутри скобок. Если <code class="notranslate">switch</code> объявляет переменную в<br/>
выражении, то переменная будет иметь соответствующий тип в каждом пункте. Также, идиоматически верно переиспользовать имена переменных для объявления новых переменных<br/>
с тем же именем, но другим типом в каждом случае:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">var</span> <span class="pl-s1">t</span> <span class="pl-k">interface</span>{}
<span class="pl-s1">t</span> <span class="pl-c1">=</span> <span class="pl-en">functionOfSomeType</span>()
<span class="pl-k">switch</span> <span class="pl-s1">t</span> <span class="pl-c1">:=</span> <span class="pl-s1">t</span>.(<span class="pl-k">type</span>) {
<span class="pl-k">default</span>:
    <span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;unexpected type %T<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">t</span>)     <span class="pl-c">// %T prints whatever type t has</span>
<span class="pl-k">case</span> <span class="pl-smi">bool</span>:
    <span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;boolean %t<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">t</span>)             <span class="pl-c">// t has type bool</span>
<span class="pl-k">case</span> <span class="pl-smi">int</span>:
    <span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;integer %d<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">t</span>)             <span class="pl-c">// t has type int</span>
<span class="pl-k">case</span> <span class="pl-c1">*</span><span class="pl-smi">bool</span>:
    <span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;pointer to boolean %t<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-c1">*</span><span class="pl-s1">t</span>) <span class="pl-c">// t has type *bool</span>
<span class="pl-k">case</span> <span class="pl-c1">*</span><span class="pl-smi">int</span>:
    <span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;pointer to integer %d<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-c1">*</span><span class="pl-s1">t</span>) <span class="pl-c">// t has type *int</span>
}</pre></div>
<h2 id="flgmgkajgLiRfCXM">Функции и методы(Functions, методы)</h2>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="hQuxOpeuQwpfPqdF">Множественное возвращение результатов</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Одно из особенностей языка Go - это то, что функции и методы могут возвращать множество значений.</p>
<p>При использовании языка С, передача ошибки производится через отрицательное значение с описанием причины ошибки в &#34;другом&#34; месте.</p>
<p>При использовании языка Go, функция <code class="notranslate">Write</code> может вернуть одновременно <strong>и</strong> возвращаемое значение <strong>и</strong> ошибку.<br/>
Сигнатура метода <code class="notranslate">Write</code> в файлах пакета <code class="notranslate">os</code>:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> (<span class="pl-s1">file</span> <span class="pl-c1">*</span><span class="pl-smi">File</span>) <span class="pl-en">Write</span>(<span class="pl-s1">b</span> []<span class="pl-smi">byte</span>) (<span class="pl-s1">n</span> <span class="pl-smi">int</span>, <span class="pl-s1">err</span> <span class="pl-smi">error</span>)</pre></div>
<p>и как предусмотрено документацией, он возвращает число записанных байт и ненулевое значение ошибки <code class="notranslate">error</code>, когда <code class="notranslate">n</code> <code class="notranslate">!=</code> <code class="notranslate">len(b)</code>.<br/>
Это общий стиль, смотрите также раздел посвящённый ошибкам в качестве примера.</p>
<p>Данный подход исключает необходимость в возращении значимого параметра.<br/>
Это очень простой способ возвращения из функции количества байт среза, возвращая число и следующий параметр.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">nextInt</span>(<span class="pl-s1">b</span> []<span class="pl-smi">byte</span>, <span class="pl-s1">i</span> <span class="pl-smi">int</span>) (<span class="pl-smi">int</span>, <span class="pl-smi">int</span>) {
    <span class="pl-k">for</span> ; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">b</span>) <span class="pl-c1">&amp;&amp;</span> <span class="pl-c1">!</span><span class="pl-en">isDigit</span>(<span class="pl-s1">b</span>[<span class="pl-s1">i</span>]); <span class="pl-s1">i</span><span class="pl-c1">++</span> {
    }
    <span class="pl-s1">x</span> <span class="pl-c1">:=</span> <span class="pl-c1">0</span>
    <span class="pl-k">for</span> ; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">b</span>) <span class="pl-c1">&amp;&amp;</span> <span class="pl-en">isDigit</span>(<span class="pl-s1">b</span>[<span class="pl-s1">i</span>]); <span class="pl-s1">i</span><span class="pl-c1">++</span> {
        <span class="pl-s1">x</span> <span class="pl-c1">=</span> <span class="pl-s1">x</span><span class="pl-c1">*</span><span class="pl-c1">10</span> <span class="pl-c1">+</span> <span class="pl-en">int</span>(<span class="pl-s1">b</span>[<span class="pl-s1">i</span>]) <span class="pl-c1">-</span> <span class="pl-s">&#39;0&#39;</span>
    }
    <span class="pl-k">return</span> <span class="pl-s1">x</span>, <span class="pl-s1">i</span>
}</pre></div>
<p>Вы можете сканировать число чисел во входном срезе <code class="notranslate">b</code> следующим образом:</p>
<div class="highlight highlight-source-go"><pre class="notranslate">    <span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">:=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">b</span>); {
        <span class="pl-s1">x</span>, <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-en">nextInt</span>(<span class="pl-s1">b</span>, <span class="pl-s1">i</span>)
        <span class="pl-s1">fmt</span>.<span class="pl-en">Println</span>(<span class="pl-s1">x</span>)
    }</pre></div>
<h3 id="EztxFYNYPIVjwlSc">Именование параметров результата</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Возвращаемым &#34;параметрам&#34; в языке Go можно давать имена и это часто используется как входные параметры.<br/>
Когда они именованы, то они инициализируются нулевым значением необходимого типа в самом начале функции.<br/>
Если функция, в которой определены именованные параметры, вызывает конструкцию возврата без аргументов, то значения именованных параметров будут использованы ей как возвращаемые значения.<br/>
Именование не обязательное, но оно может сделать код короче и чище - самодокументированным.<br/>
Если имя результата будет <code class="notranslate">nextInt</code>, то очевидно что тип результата <code class="notranslate">int</code>.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">nextInt</span>(<span class="pl-s1">b</span> []<span class="pl-smi">byte</span>, <span class="pl-s1">pos</span> <span class="pl-smi">int</span>) (<span class="pl-s1">value</span>, <span class="pl-s1">nextPos</span> <span class="pl-smi">int</span>) {</pre></div>
<p>На примере <code class="notranslate">io.ReadFull</code>:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">ReadFull</span>(<span class="pl-s1">r</span> <span class="pl-smi">Reader</span>, <span class="pl-s1">buf</span> []<span class="pl-smi">byte</span>) (<span class="pl-s1">n</span> <span class="pl-smi">int</span>, <span class="pl-s1">err</span> <span class="pl-smi">error</span>) {
    <span class="pl-k">for</span> <span class="pl-en">len</span>(<span class="pl-s1">buf</span>) <span class="pl-c1">&gt;</span> <span class="pl-c1">0</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-s1">err</span> <span class="pl-c1">==</span> <span class="pl-c1">nil</span> {
        <span class="pl-k">var</span> <span class="pl-s1">nr</span> <span class="pl-smi">int</span>
        <span class="pl-s1">nr</span>, <span class="pl-s1">err</span> <span class="pl-c1">=</span> <span class="pl-s1">r</span>.<span class="pl-en">Read</span>(<span class="pl-s1">buf</span>)
        <span class="pl-s1">n</span> <span class="pl-c1">+=</span> <span class="pl-s1">nr</span>
        <span class="pl-s1">buf</span> <span class="pl-c1">=</span> <span class="pl-s1">buf</span>[<span class="pl-s1">nr</span>:]
    }
    <span class="pl-k">return</span>
}</pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="mdIjbvBKkOGJyJKd">Отсроченный вызов (Defer)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>В языке Go есть оператор <code class="notranslate">defer</code> для управления отложенного вызова функции, который будет вызван, как только функция имеющая <code class="notranslate">defer</code> оканчивается.<br/>
Это не типичный но эффективный способ, когда необходимо закрыть ресурс после окончания функции.<br/>
Канонические примеры - работа с mutex или закрытие файла.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// Contents returns the file&#39;s contents as a string.</span>
<span class="pl-k">func</span> <span class="pl-en">Contents</span>(<span class="pl-s1">filename</span> <span class="pl-smi">string</span>) (<span class="pl-smi">string</span>, <span class="pl-smi">error</span>) {
    <span class="pl-s1">f</span>, <span class="pl-s1">err</span> <span class="pl-c1">:=</span> <span class="pl-s1">os</span>.<span class="pl-en">Open</span>(<span class="pl-s1">filename</span>)
    <span class="pl-k">if</span> <span class="pl-s1">err</span> <span class="pl-c1">!=</span> <span class="pl-c1">nil</span> {
        <span class="pl-k">return</span> <span class="pl-s">&#34;&#34;</span>, <span class="pl-s1">err</span>
    }
    <span class="pl-k">defer</span> <span class="pl-s1">f</span>.<span class="pl-en">Close</span>()  <span class="pl-c">// f.Close will run when we&#39;re finished.</span>

    <span class="pl-k">var</span> <span class="pl-s1">result</span> []<span class="pl-smi">byte</span>
    <span class="pl-s1">buf</span> <span class="pl-c1">:=</span> <span class="pl-en">make</span>([]<span class="pl-smi">byte</span>, <span class="pl-c1">100</span>)
    <span class="pl-k">for</span> {
        <span class="pl-s1">n</span>, <span class="pl-s1">err</span> <span class="pl-c1">:=</span> <span class="pl-s1">f</span>.<span class="pl-en">Read</span>(<span class="pl-s1">buf</span>[<span class="pl-c1">0</span>:])
        <span class="pl-s1">result</span> <span class="pl-c1">=</span> <span class="pl-en">append</span>(<span class="pl-s1">result</span>, <span class="pl-s1">buf</span>[<span class="pl-c1">0</span>:<span class="pl-s1">n</span>]<span class="pl-c1">...</span>) <span class="pl-c">// append is discussed later.</span>
        <span class="pl-k">if</span> <span class="pl-s1">err</span> <span class="pl-c1">!=</span> <span class="pl-c1">nil</span> {
            <span class="pl-k">if</span> <span class="pl-s1">err</span> <span class="pl-c1">==</span> <span class="pl-s1">io</span>.<span class="pl-c1">EOF</span> {
                <span class="pl-k">break</span>
            }
            <span class="pl-k">return</span> <span class="pl-s">&#34;&#34;</span>, <span class="pl-s1">err</span>  <span class="pl-c">// f will be closed if we return here.</span>
        }
    }
    <span class="pl-k">return</span> <span class="pl-en">string</span>(<span class="pl-s1">result</span>), <span class="pl-c1">nil</span> <span class="pl-c">// f will be closed if we return here.</span>
}</pre></div>
<p>Отложенный вызов функции <code class="notranslate">Close</code> имеет 2 преимущества. Во-первых, гарантирует что не будет забыто закрытие файла - ошибка,  которую легко сделать, если в последствии в функции будет изменен параметр на другую папку. Во-вторых, закрытие близко расположено к открытию, что более ясно, чем располагать его в конце функции.</p>
<p>Аргументы отложенной функции выполняются когда выполняется <code class="notranslate">defer</code>, а не когда функция вызвана.<br/>
Кроме того , во избежания беспокойства по поводу изменяющихся переменных в функции, одна отложенная функция может отложить вызов множества функций.</p>
<p>Вот простой пример:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">:=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">5</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span> {
    <span class="pl-k">defer</span> <span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;%d &#34;</span>, <span class="pl-s1">i</span>)
}</pre></div>
<p>Откладывание функции в LIFO очередь, приведет к следующей работе функции при печати на экран <code class="notranslate">4 3 2 1 0</code> . Более интересный пример - простое отслеживание функции в программе. Мы могли бы написать простое отслеживание, как это:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">trace</span>(<span class="pl-s1">s</span> <span class="pl-smi">string</span>)   { <span class="pl-s1">fmt</span>.<span class="pl-en">Println</span>(<span class="pl-s">&#34;entering:&#34;</span>, <span class="pl-s1">s</span>) }
<span class="pl-k">func</span> <span class="pl-en">untrace</span>(<span class="pl-s1">s</span> <span class="pl-smi">string</span>) { <span class="pl-s1">fmt</span>.<span class="pl-en">Println</span>(<span class="pl-s">&#34;leaving:&#34;</span>, <span class="pl-s1">s</span>) }

<span class="pl-c">// Use them like this:</span>
<span class="pl-k">func</span> <span class="pl-en">a</span>() {
    <span class="pl-en">trace</span>(<span class="pl-s">&#34;a&#34;</span>)
    <span class="pl-k">defer</span> <span class="pl-en">untrace</span>(<span class="pl-s">&#34;a&#34;</span>)
    <span class="pl-c">// do something....</span>
}</pre></div>
<p>Мы могли бы сделать лучше - используя факт отложенных функций для оценки когда будет запущен <code class="notranslate">defer</code>. Отслеживаемая функция может настроить аргументы неотслеживаемой функции.<br/>
К примеру:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">trace</span>(<span class="pl-s1">s</span> <span class="pl-smi">string</span>) <span class="pl-smi">string</span> {
    <span class="pl-s1">fmt</span>.<span class="pl-en">Println</span>(<span class="pl-s">&#34;entering:&#34;</span>, <span class="pl-s1">s</span>)
    <span class="pl-k">return</span> <span class="pl-s1">s</span>
}

<span class="pl-k">func</span> <span class="pl-en">un</span>(<span class="pl-s1">s</span> <span class="pl-smi">string</span>) {
    <span class="pl-s1">fmt</span>.<span class="pl-en">Println</span>(<span class="pl-s">&#34;leaving:&#34;</span>, <span class="pl-s1">s</span>)
}

<span class="pl-k">func</span> <span class="pl-en">a</span>() {
    <span class="pl-k">defer</span> <span class="pl-en">un</span>(<span class="pl-en">trace</span>(<span class="pl-s">&#34;a&#34;</span>))
    <span class="pl-s1">fmt</span>.<span class="pl-en">Println</span>(<span class="pl-s">&#34;in a&#34;</span>)
}

<span class="pl-k">func</span> <span class="pl-en">b</span>() {
    <span class="pl-k">defer</span> <span class="pl-en">un</span>(<span class="pl-en">trace</span>(<span class="pl-s">&#34;b&#34;</span>))
    <span class="pl-s1">fmt</span>.<span class="pl-en">Println</span>(<span class="pl-s">&#34;in b&#34;</span>)
    <span class="pl-en">a</span>()
}

<span class="pl-k">func</span> <span class="pl-en">main</span>() {
    <span class="pl-en">b</span>()
}</pre></div>
<p>выводит:</p>
<pre class="notranslate"><code class="notranslate">entering: b
in b
entering: a
in a
leaving: a
leaving: b
</code></pre>
<p>Для программистов привыкших к блочному управлению ресурсами в других языках, функция <code class="notranslate">defer</code> может показаться странной, но интересной и мощной, так как позволяет уйти от блочного управления к управлению в функции. В разделах <code class="notranslate">panic</code> и <code class="notranslate">recover</code> будут также рассматриваться несколько примеров.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h2 id="XItOzWilPcTzNzTI">Данные</h2>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="lcIzANjqvBJOstgz">Созданные с помощью <code class="notranslate">new</code></h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Для создания примитивов в языке Go используются функции <code class="notranslate">new</code> и <code class="notranslate">make</code>.<br/>
Они разные и применяются для разных типов, это может сбить с толку, но правило очень просто.<br/>
Для начала обсудим функцию <code class="notranslate">new</code>.<br/>
Данная функция резервирует память, но не также как в других языках программирования, она не просто <em>инициализирует</em> память, а вместо этого заполняет <em>нулями</em>.</p>
<p>К примеру <code class="notranslate">new(T)</code> резервирует память нулями для нового элемента типа <code class="notranslate">T</code> и возвращает его указатель на значение типа <code class="notranslate">*T</code>. В терминологии Go, он возвращает указатель на новую зарезервированную память заполненная нулями с типом <code class="notranslate">T</code>.</p>
<p><strong>TODO</strong><br/>
Since the memory returned by <code class="notranslate">new</code> is zeroed, it&#39;s helpful to arrange when designing your data structures that the zero value of each type can be used without further initialization.  This means a user of the data structure can create one with <code class="notranslate">new</code> and get right to work.<br/>
For example, the documentation for <code class="notranslate">bytes.Buffer</code> states that &#34;the zero value for <code class="notranslate">Buffer</code> is an empty buffer ready to use.&#34;<br/>
Similarly, <code class="notranslate">sync.Mutex</code> does not have an explicit constructor or <code class="notranslate">Init</code> method.<br/>
Instead, the zero value for a <code class="notranslate">sync.Mutex</code> is defined to be an unlocked mutex.<br/>
The zero-value-is-useful property works transitively. Consider this type declaration.<br/>
<strong>-</strong></p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">SyncedBuffer</span> <span class="pl-k">struct</span> {
    <span class="pl-c1">lock</span>    sync.<span class="pl-smi">Mutex</span>
    <span class="pl-c1">buffer</span>  bytes.<span class="pl-smi">Buffer</span>
}</pre></div>
<p><strong>TODO</strong><br/>
Values of type <code class="notranslate">SyncedBuffer</code> are also ready to use immediately upon allocation or just declaration.  In the next snippet, both <code class="notranslate">p</code> and <code class="notranslate">v</code> will work correctly without further arrangement.<br/>
<strong>-</strong></p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">p</span> <span class="pl-c1">:=</span> <span class="pl-en">new</span>(<span class="pl-smi">SyncedBuffer</span>)  <span class="pl-c">// type *SyncedBuffer</span>
<span class="pl-k">var</span> <span class="pl-s1">v</span> <span class="pl-smi">SyncedBuffer</span>      <span class="pl-c">// type  SyncedBuffer</span></pre></div>
<h3 id="heoIrbohJnCcMQjG">Конструкторы и составные литералы</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Иногда нулевых значений не достаточно и необходимо иметь конструктор, следующий пример взят из пакета <code class="notranslate">os</code>.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">NewFile</span>(<span class="pl-s1">fd</span> <span class="pl-smi">int</span>, <span class="pl-s1">name</span> <span class="pl-smi">string</span>) <span class="pl-c1">*</span><span class="pl-smi">File</span> {
    <span class="pl-k">if</span> <span class="pl-s1">fd</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">0</span> {
        <span class="pl-k">return</span> <span class="pl-c1">nil</span>
    }
    <span class="pl-s1">f</span> <span class="pl-c1">:=</span> <span class="pl-en">new</span>(<span class="pl-smi">File</span>)
    <span class="pl-s1">f</span>.<span class="pl-c1">fd</span> <span class="pl-c1">=</span> <span class="pl-s1">fd</span>
    <span class="pl-s1">f</span>.<span class="pl-c1">name</span> <span class="pl-c1">=</span> <span class="pl-s1">name</span>
    <span class="pl-s1">f</span>.<span class="pl-c1">dirinfo</span> <span class="pl-c1">=</span> <span class="pl-c1">nil</span>
    <span class="pl-s1">f</span>.<span class="pl-c1">nepipe</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">return</span> <span class="pl-s1">f</span>
}</pre></div>
<p>Существует много шаблонов. Мы просто можем использовать <em>составные литералы</em>, которые будут создавать новые сущности каждый раз.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">NewFile</span>(<span class="pl-s1">fd</span> <span class="pl-smi">int</span>, <span class="pl-s1">name</span> <span class="pl-smi">string</span>) <span class="pl-c1">*</span><span class="pl-smi">File</span> {
    <span class="pl-k">if</span> <span class="pl-s1">fd</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">0</span> {
        <span class="pl-k">return</span> <span class="pl-c1">nil</span>
    }
    <span class="pl-s1">f</span> <span class="pl-c1">:=</span> <span class="pl-smi">File</span>{<span class="pl-s1">fd</span>, <span class="pl-s1">name</span>, <span class="pl-c1">nil</span>, <span class="pl-c1">0</span>}
    <span class="pl-k">return</span> <span class="pl-c1">&amp;</span><span class="pl-s1">f</span>
}</pre></div>
<p>Обратите внимание на то, что в отличии от языка С, это нормально, возвращать адрес локальных переменных, так как переменная уже существует после возвращения из функции.<br/>
На самом деле, возвращение адресов составных литералов создает новую сущность каждый раз, как он вычисляется.<br/>
Итак мы можем объединить последние две строки:</p>
<div class="highlight highlight-source-go"><pre class="notranslate">    <span class="pl-k">return</span> <span class="pl-c1">&amp;</span><span class="pl-smi">File</span>{<span class="pl-s1">fd</span>, <span class="pl-s1">name</span>, <span class="pl-c1">nil</span>, <span class="pl-c1">0</span>}</pre></div>
<p>Поля составных литералов должны быть в порядке объявления и все должны присутствовать.<br/>
Однако, используя маркировку как пара <em>поле</em><code class="notranslate">:</code><em>значение</em>, могут инициализироваться в любом порядке, с пропущенными полями заполняемые нулями.<br/>
Таким образом, можно объявить:</p>
<div class="highlight highlight-source-go"><pre class="notranslate">    <span class="pl-k">return</span> <span class="pl-c1">&amp;</span><span class="pl-smi">File</span>{<span class="pl-c1">fd</span>: <span class="pl-s1">fd</span>, <span class="pl-c1">name</span>: <span class="pl-s1">name</span>}</pre></div>
<p>В предельном случае, когда составной литерал без полей вообще, то создание нулевым значением будет тип. Выражения <code class="notranslate">new(File)</code> и <code class="notranslate">&amp;File{}</code> одинаковы.</p>
<p>Составные литералы могут также создавать массивы, срезы, карты, с пометкой полей как индексов или ключами карт.<br/>
К примеру, инициализированные значения <code class="notranslate">Enone</code>, <code class="notranslate">Eio</code>, и <code class="notranslate">Einval</code> разные.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">a</span> <span class="pl-c1">:=</span> [<span class="pl-c1">...</span>]<span class="pl-smi">string</span>   {<span class="pl-c1">Enone</span>: <span class="pl-s">&#34;no error&#34;</span>, <span class="pl-c1">Eio</span>: <span class="pl-s">&#34;Eio&#34;</span>, <span class="pl-c1">Einval</span>: <span class="pl-s">&#34;invalid argument&#34;</span>}
<span class="pl-s1">s</span> <span class="pl-c1">:=</span> []<span class="pl-smi">string</span>      {<span class="pl-c1">Enone</span>: <span class="pl-s">&#34;no error&#34;</span>, <span class="pl-c1">Eio</span>: <span class="pl-s">&#34;Eio&#34;</span>, <span class="pl-c1">Einval</span>: <span class="pl-s">&#34;invalid argument&#34;</span>}
<span class="pl-s1">m</span> <span class="pl-c1">:=</span> <span class="pl-k">map</span>[<span class="pl-smi">int</span>]<span class="pl-smi">string</span>{<span class="pl-c1">Enone</span>: <span class="pl-s">&#34;no error&#34;</span>, <span class="pl-c1">Eio</span>: <span class="pl-s">&#34;Eio&#34;</span>, <span class="pl-c1">Einval</span>: <span class="pl-s">&#34;invalid argument&#34;</span>}</pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="QMwHFcoTFbVuNxnC">Создание с помощью <code class="notranslate">make</code></h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Возвращаясь к созданию элементов.<br/>
Встроенная функция <code class="notranslate">make(T, </code><em>args</em><code class="notranslate">)</code> служит для других целей нежели <code class="notranslate">new(T)</code>.<br/>
Он создает только срезы, карты и каналы, и возвращают <em>инициализированные</em> (не нулевые) значение типа <code class="notranslate">T</code> (а не <code class="notranslate">*T</code>).<br/>
Причиной различия для этих трех типов, в том что внутри они представляют из себя структуры данных, которые необходимо инициализировать перед использованием.<br/>
К примеру, срезы - это трехэлементная структура, содержащая указатель на данные(внутри массив), длину, и емкость, причём пока все элементы не инициализированы - срез  <em>нулевой</em> <code class="notranslate">nil</code>.<br/>
Для срезов, карт и каналов, встроенная команда <code class="notranslate">make</code> инициализирует внутреннюю структуру данных и подготавливает значения к использованию.</p>
<p>К примеру:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-en">make</span>([]<span class="pl-smi">int</span>, <span class="pl-c1">10</span>, <span class="pl-c1">100</span>)</pre></div>
<p>создает массив из 100 значений типа <code class="notranslate">int</code> и затем создает структуру среза длинной 10 и емкостью 100 со ссылкой только на первые 10 элементов.<br/>
(Когда создается слайс, его емкость задавать не обязательно, смотрите раздел посвящённый срезам.)<br/>
В противоположность, <code class="notranslate">new([]int)</code> возвращает указатель на новый, созданный, заполненный нулями срез, это указатель на значение <code class="notranslate">nil</code> среза.</p>
<p>Эти примеры показывают различие между <code class="notranslate">new</code> и <code class="notranslate">make</code>.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">var</span> <span class="pl-s1">p</span> <span class="pl-c1">*</span>[]<span class="pl-smi">int</span> <span class="pl-c1">=</span> <span class="pl-en">new</span>([]<span class="pl-smi">int</span>)       <span class="pl-c">// allocates slice structure; *p == nil; rarely useful</span>
<span class="pl-k">var</span> <span class="pl-s1">v</span>  []<span class="pl-smi">int</span> <span class="pl-c1">=</span> <span class="pl-en">make</span>([]<span class="pl-smi">int</span>, <span class="pl-c1">100</span>) <span class="pl-c">// the slice v now refers to a new array of 100 ints</span>

<span class="pl-c">// Unnecessarily complex:</span>
<span class="pl-k">var</span> <span class="pl-s1">p</span> <span class="pl-c1">*</span>[]<span class="pl-smi">int</span> <span class="pl-c1">=</span> <span class="pl-en">new</span>([]<span class="pl-smi">int</span>)
<span class="pl-c1">*</span><span class="pl-s1">p</span> <span class="pl-c1">=</span> <span class="pl-en">make</span>([]<span class="pl-smi">int</span>, <span class="pl-c1">100</span>, <span class="pl-c1">100</span>)

<span class="pl-c">// Idiomatic:</span>
<span class="pl-s1">v</span> <span class="pl-c1">:=</span> <span class="pl-en">make</span>([]<span class="pl-smi">int</span>, <span class="pl-c1">100</span>)</pre></div>
<p>Помните что <code class="notranslate">make</code> используется только для карт, срезов и каналов и не возвращают указатель.<br/>
Для получения указателя в явном виде используйте <code class="notranslate">new</code> или  возьмите указатель в явном виде.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="nlAEXwboUtcScxjc">Массивы</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Массивы популярны когда точно известно необходимое количество памяти, чтобы не делать излишних пересозданий, но в первую очередь они являются составной частью для срезов, о которых будет описано в следующем разделе.</p>
<p>Какие основные отличия между обращением с массивами между языками Go и C:</p>
<ul>
<li>Массивы значений. Присвоение одно массива другому копирует все элементы.</li>
<li>Если вы передаёте массив в функцию, то передаётся копия массива, а не указатель на него.</li>
<li>Размер массива является частью массива. Типы <code class="notranslate">[10]int</code> и <code class="notranslate">[20]int</code> разные.</li>
</ul>
<p>Массивы могут быть полезными, но дорогими(с точки зрения производительности) и если Вы хотите иметь гибкость и эффективность схожее с поведением в языке C-like, то необходимо использовать в функциях указатели.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">Sum</span>(<span class="pl-s1">a</span> <span class="pl-c1">*</span>[<span class="pl-c1">3</span>]<span class="pl-smi">float64</span>) (<span class="pl-s1">sum</span> <span class="pl-smi">float64</span>) {
    <span class="pl-k">for</span> <span class="pl-s1">_</span>, <span class="pl-s1">v</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-c1">*</span><span class="pl-s1">a</span> {
        <span class="pl-s1">sum</span> <span class="pl-c1">+=</span> <span class="pl-s1">v</span>
    }
    <span class="pl-k">return</span>
}

<span class="pl-s1">array</span> <span class="pl-c1">:=</span> [<span class="pl-c1">...</span>]<span class="pl-smi">float64</span>{<span class="pl-c1">7.0</span>, <span class="pl-c1">8.5</span>, <span class="pl-c1">9.1</span>}
<span class="pl-s1">x</span> <span class="pl-c1">:=</span> <span class="pl-en">Sum</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">array</span>)  <span class="pl-c">// Note the explicit address-of operator</span></pre></div>
<p>Но данный стиль не подходит Go.<br/>
Используйте срезы вместо массивов.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="xfbVtFBbGlVsjyxn">Срезы(Slices, слайсы)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Срезы это обёртка для массивов и при этом более общий и мощный, и предоставляет собой более удобный интерфейс по управлению данными, в случаях, когда не известно точное количество элементов и необходимо преобразование размера массивов.<br/>
Большинство программ на языке Go, выполнены с использованием срезов, а не простых массивов.</p>
<p>Срез хранит ссылку на массив и поэтому если приравнять срез к другому срезу, то будет тот же массив.<br/>
Если срез является аргументом функции, то изменения элементов в срезе будут видны вызывающему данному функцию, это аналогично передаче указателя на базовый массив.<br/>
В функция <code class="notranslate">Read</code> может принимать в качестве аргумента срез, что равнозначно указателю на массив и длины массива; длина среза указывает верхний предел количество данных которые необходимо прочитать.<br/>
В данном случае тип <code class="notranslate">File</code> пакета <code class="notranslate">os</code> имеет следующую сигнатуру метода <code class="notranslate">Read</code>:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> (<span class="pl-s1">f</span> <span class="pl-c1">*</span> <span class="pl-smi">File</span>) <span class="pl-en">Read</span>(<span class="pl-s1">buf</span> []<span class="pl-smi">byte</span>) (<span class="pl-s1">n</span> <span class="pl-smi">int</span>, <span class="pl-s1">err</span> <span class="pl-smi">error</span>)</pre></div>
<p>Метод возвращает количество прочитанных байт или если есть, то ошибку.<br/>
Для чтения первых 32 байт в буфере <code class="notranslate">buf</code>, <em>получить(срезать) часть</em> буфера.</p>
<div class="highlight highlight-source-go"><pre class="notranslate">    <span class="pl-s1">n</span>, <span class="pl-s1">err</span> <span class="pl-c1">:=</span> <span class="pl-s1">f</span>.<span class="pl-en">Read</span>(<span class="pl-s1">buf</span>[<span class="pl-c1">0</span>:<span class="pl-c1">32</span>])</pre></div>
<p>Такой срез является эффективным. На самом деле, если оставить в стороне эффективность, то следующий пример показывает чтение первых 32 байт из буфера.</p>
<div class="highlight highlight-source-go"><pre class="notranslate">    <span class="pl-k">var</span> <span class="pl-s1">n</span> <span class="pl-smi">int</span>
    <span class="pl-k">var</span> <span class="pl-s1">err</span> <span class="pl-smi">error</span>
    <span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">:=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">32</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span> {
        <span class="pl-s1">nbytes</span>, <span class="pl-s1">e</span> <span class="pl-c1">:=</span> <span class="pl-s1">f</span>.<span class="pl-en">Read</span>(<span class="pl-s1">buf</span>[<span class="pl-s1">i</span>:<span class="pl-s1">i</span><span class="pl-c1">+</span><span class="pl-c1">1</span>])  <span class="pl-c">// Read one byte.</span>
        <span class="pl-k">if</span> <span class="pl-s1">nbytes</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span> <span class="pl-c1">||</span> <span class="pl-s1">e</span> <span class="pl-c1">!=</span> <span class="pl-c1">nil</span> {
            <span class="pl-s1">err</span> <span class="pl-c1">=</span> <span class="pl-s1">e</span>
            <span class="pl-k">break</span>
        }
        <span class="pl-s1">n</span> <span class="pl-c1">+=</span> <span class="pl-s1">nbytes</span>
    }</pre></div>
<p>Длина среза может меняться, пока не исчерпает размер внутреннего массива.<br/>
С помощью встроенной функции <code class="notranslate">cap</code> можно узнать <em>емкость</em> среза, представляющий максимальную длину среза.<br/>
В следующем примере рассматривается функция для добавления данных в срез.<br/>
Если данные превышают ёмкость среза, то срез необходимо переопределить.<br/>
Функция <code class="notranslate">Append</code> возвращает результирующий срез. Функция использует тот факт что  использование <code class="notranslate">len</code> и <code class="notranslate">cap</code> допустимо, даже если у нас имеется нулевой срез <code class="notranslate">nil</code> - при этом возвращая 0.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">Append</span>(<span class="pl-s1">slice</span>, <span class="pl-s1">data</span> []<span class="pl-smi">byte</span>) []<span class="pl-smi">byte</span> {
    <span class="pl-s1">l</span> <span class="pl-c1">:=</span> <span class="pl-en">len</span>(<span class="pl-s1">slice</span>)
    <span class="pl-k">if</span> <span class="pl-s1">l</span> <span class="pl-c1">+</span> <span class="pl-en">len</span>(<span class="pl-s1">data</span>) <span class="pl-c1">&gt;</span> <span class="pl-en">cap</span>(<span class="pl-s1">slice</span>) {  <span class="pl-c">// reallocate</span>
        <span class="pl-c">// Allocate double what&#39;s needed, for future growth.</span>
        <span class="pl-s1">newSlice</span> <span class="pl-c1">:=</span> <span class="pl-en">make</span>([]<span class="pl-smi">byte</span>, (<span class="pl-s1">l</span><span class="pl-c1">+</span><span class="pl-en">len</span>(<span class="pl-s1">data</span>))<span class="pl-c1">*</span> <span class="pl-c1">2</span>)
        <span class="pl-c">// The copy function is predeclared and works for any slice type.</span>
        <span class="pl-en">copy</span>(<span class="pl-s1">newSlice</span>, <span class="pl-s1">slice</span>)
        <span class="pl-s1">slice</span> <span class="pl-c1">=</span> <span class="pl-s1">newSlice</span>
    }
    <span class="pl-s1">slice</span> <span class="pl-c1">=</span> <span class="pl-s1">slice</span>[<span class="pl-c1">0</span>:<span class="pl-s1">l</span><span class="pl-c1">+</span><span class="pl-en">len</span>(<span class="pl-s1">data</span>)]
    <span class="pl-k">for</span> <span class="pl-s1">i</span>, <span class="pl-s1">c</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-s1">data</span> {
        <span class="pl-s1">slice</span>[<span class="pl-s1">l</span><span class="pl-c1">+</span><span class="pl-s1">i</span>] <span class="pl-c1">=</span> <span class="pl-s1">c</span>
    }
    <span class="pl-k">return</span> <span class="pl-s1">slice</span>
}</pre></div>
<p><strong>TODO</strong><br/>
We must return the slice afterwards because, although <code class="notranslate">Append</code><br/>
can modify the elements of <code class="notranslate">slice</code>, the slice itself (the run-time data<br/>
structure holding the pointer, length, and capacity) is passed by value.<br/>
<strong>-</strong></p>
<p>Добавление элементов в срез настолько популярно, что функция <code class="notranslate">append</code> стала встроенной. Для того чтобы понять принцип работы данной функции нам необходимо больше информации, поэтому мы вернёмся к этому позже.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="kipNRySySuMazpzq">Двухмерные срезы</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Массивы и срезы в Go - одномерные.<br/>
Для создания двухмерного массива или среза, нам необходимо определять массив-массивов или срез-срезов, как в примере:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">Transform</span> [<span class="pl-c1">3</span>][<span class="pl-c1">3</span>]<span class="pl-smi">float64</span>  <span class="pl-c">// A 3x3 array, really an array of arrays.</span>
<span class="pl-k">type</span> <span class="pl-smi">LinesOfText</span> [][]<span class="pl-smi">byte</span>     <span class="pl-c">// A slice of byte slices.</span></pre></div>
<p>В связи с тем, что срезы переменной длины, то допустимо иметь каждый внутренний срез разной длины.<br/>
Это наиболее общая ситуация, как в примере <code class="notranslate">LinesOfText</code>, в котором каждая строка имеет независимую длину.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">text</span> <span class="pl-c1">:=</span> <span class="pl-smi">LinesOfText</span>{
	[]<span class="pl-smi">byte</span>(<span class="pl-s">&#34;Now is the time&#34;</span>),
	[]<span class="pl-smi">byte</span>(<span class="pl-s">&#34;for all good gophers&#34;</span>),
	[]<span class="pl-smi">byte</span>(<span class="pl-s">&#34;to bring some fun to the party.&#34;</span>),
}</pre></div>
<p>Иногда необходимо создавать двухмерные срезы, к примеру при обработки пикселей.<br/>
Есть 2 способа для этого:</p>
<ul>
<li>Первый, создание каждого среза независимо</li>
<li>Второй, создание простого массива срезов.<br/>
Наилучший способ выбирается в зависимости от программы.<br/>
Если срез можно увеличивать или уменьшать, они должны быть независимы, для того чтобы избежать перезаписи новых строк. Если не требуется изменять размер, то наиболее эффективным был бы способ с создание одним их аллоцированием(инициализацией).<br/>
Рассмотрим оба способа.</li>
</ul>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// Allocate the top-level slice.</span>
<span class="pl-s1">picture</span> <span class="pl-c1">:=</span> <span class="pl-en">make</span>([][]<span class="pl-smi">uint8</span>, <span class="pl-s1">YSize</span>) <span class="pl-c">// One row per unit of y.</span>
<span class="pl-c">// Loop over the rows, allocating the slice for each row.</span>
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-s1">picture</span> {
	<span class="pl-s1">picture</span>[<span class="pl-s1">i</span>] <span class="pl-c1">=</span> <span class="pl-en">make</span>([]<span class="pl-smi">uint8</span>, <span class="pl-s1">XSize</span>)
}</pre></div>
<p>с одним созданием:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// Allocate the top-level slice, the same as before.</span>
<span class="pl-s1">picture</span> <span class="pl-c1">:=</span> <span class="pl-en">make</span>([][]<span class="pl-smi">uint8</span>, <span class="pl-s1">YSize</span>) <span class="pl-c">// One row per unit of y.</span>
<span class="pl-c">// Allocate one large slice to hold all the pixels.</span>
<span class="pl-s1">pixels</span> <span class="pl-c1">:=</span> <span class="pl-en">make</span>([]<span class="pl-smi">uint8</span>, <span class="pl-s1">XSize</span><span class="pl-c1">*</span><span class="pl-s1">YSize</span>) <span class="pl-c">// Has type []uint8 even though picture is [][]uint8.</span>
<span class="pl-c">// Loop over the rows, slicing each row from the front of the remaining pixels slice.</span>
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-s1">picture</span> {
	<span class="pl-s1">picture</span>[<span class="pl-s1">i</span>], <span class="pl-s1">pixels</span> <span class="pl-c1">=</span> <span class="pl-s1">pixels</span>[:<span class="pl-s1">XSize</span>], <span class="pl-s1">pixels</span>[<span class="pl-s1">XSize</span>:]
}</pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="YXsabDdwubRKKeiw">Карты(Maps)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Карты - это удобная и мощная встроенная структура данных, связывающая значение одного типа(<em>ключ (key)</em>) со значением другого типа (<em>элемент (element)</em> или <em>значение (value)</em>).<br/>
Ключ может быть любого типа, для которого определён оператор равно, как для целых чисел, чисел с плавающей точкой или комплексные числа, строки, указатели, интерфейсы (если динамические типы поддерживают равенство), структуры и массивы.<br/>
Срезы не используются в качестве ключа для карт, так как равенство не определено для них.<br/>
Карты, также как и срезы, имеют внутреннюю структуру данных.<br/>
Если Вы передадите карту в функции и измените содержание карты, то изменения останутся для вызывающего.<br/>
Карты могут быть созданы с использованием синтаксиса составных литералов с разделением по колонкам пар ключ-значение, поэтому легко создать начальные данные.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">var</span> <span class="pl-s1">timeZone</span> <span class="pl-c1">=</span> <span class="pl-k">map</span>[<span class="pl-smi">string</span>]<span class="pl-smi">int</span>{
    <span class="pl-s">&#34;UTC&#34;</span>:  <span class="pl-c1">0</span><span class="pl-c1">*</span><span class="pl-c1">60</span><span class="pl-c1">*</span><span class="pl-c1">60</span>,
    <span class="pl-s">&#34;EST&#34;</span>: <span class="pl-c1">-</span><span class="pl-c1">5</span><span class="pl-c1">*</span><span class="pl-c1">60</span><span class="pl-c1">*</span><span class="pl-c1">60</span>,
    <span class="pl-s">&#34;CST&#34;</span>: <span class="pl-c1">-</span><span class="pl-c1">6</span><span class="pl-c1">*</span><span class="pl-c1">60</span><span class="pl-c1">*</span><span class="pl-c1">60</span>,
    <span class="pl-s">&#34;MST&#34;</span>: <span class="pl-c1">-</span><span class="pl-c1">7</span><span class="pl-c1">*</span><span class="pl-c1">60</span><span class="pl-c1">*</span><span class="pl-c1">60</span>,
    <span class="pl-s">&#34;PST&#34;</span>: <span class="pl-c1">-</span><span class="pl-c1">8</span><span class="pl-c1">*</span><span class="pl-c1">60</span><span class="pl-c1">*</span><span class="pl-c1">60</span>,
}</pre></div>
<p>Добавление и получение значений из карт, синтаксически, выглядит как для массивов или срезов, за тем исключением того что индекс не обязательно должен быть целым числом.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">offset</span> <span class="pl-c1">:=</span> <span class="pl-s1">timeZone</span>[<span class="pl-s">&#34;EST&#34;</span>]</pre></div>
<p>При попытке получения значения из карты по ключу, которого нет в карте, приведёт к возвращению нулевого значения.<br/>
К примеру, если карта содержит целые числа, как описывалось выше, для несуществующего ключа будет возвращено <code class="notranslate">0</code>.<br/>
Это можно представить как карту у которой в качестве типа значения используется <code class="notranslate">bool</code>. Добавление записи в карту это как добавление со значением <code class="notranslate">true</code> в карту и дальнейшая простая проверка на индексирование.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">attended</span> <span class="pl-c1">:=</span> <span class="pl-k">map</span>[<span class="pl-smi">string</span>]<span class="pl-smi">bool</span>{
    <span class="pl-s">&#34;Ann&#34;</span>: <span class="pl-c1">true</span>,
    <span class="pl-s">&#34;Joe&#34;</span>: <span class="pl-c1">true</span>,
    <span class="pl-c1">...</span>
}

<span class="pl-k">if</span> <span class="pl-s1">attended</span>[<span class="pl-s1">person</span>] { <span class="pl-c">// will be false if person is not in the map</span>
    <span class="pl-s1">fmt</span>.<span class="pl-en">Println</span>(<span class="pl-s1">person</span>, <span class="pl-s">&#34;was at the meeting&#34;</span>)
}</pre></div>
<p>Иногда необходимо отличать отсутствие записи от нулевого значения. К примеру, есть ли запись для <code class="notranslate">&#34;UTC&#34;</code> или это пустая строка потому что отсутствует значение в карте?<br/>
Для того чтобы отличить - Вы можете использовать множественное присвоение.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">var</span> <span class="pl-s1">seconds</span> <span class="pl-smi">int</span>
<span class="pl-k">var</span> <span class="pl-s1">ok</span> <span class="pl-smi">bool</span>
<span class="pl-s1">seconds</span>, <span class="pl-s1">ok</span> <span class="pl-c1">=</span> <span class="pl-s1">timeZone</span>[<span class="pl-s1">tz</span>]</pre></div>
<p>Очевидная причина называть данную идиому &#34;запятая ок&#34;.<br/>
В данном примере, если <code class="notranslate">tz</code> существует, то <code class="notranslate">seconds</code> будет иметь необходимое значение и <code class="notranslate">ok</code> будет <code class="notranslate">true</code>, но если не существует, то <code class="notranslate">seconds</code> будет иметь нулевое значение а <code class="notranslate">ok</code> будет <code class="notranslate">false</code>.<br/>
В следующем примере, представлена функция с хорошим описанием ошибки:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">offset</span>(<span class="pl-s1">tz</span> <span class="pl-smi">string</span>) <span class="pl-smi">int</span> {
    <span class="pl-k">if</span> <span class="pl-s1">seconds</span>, <span class="pl-s1">ok</span> <span class="pl-c1">:=</span> <span class="pl-s1">timeZone</span>[<span class="pl-s1">tz</span>]; <span class="pl-s1">ok</span> {
        <span class="pl-k">return</span> <span class="pl-s1">seconds</span>
    }
    <span class="pl-s1">log</span>.<span class="pl-en">Println</span>(<span class="pl-s">&#34;unknown time zone:&#34;</span>, <span class="pl-s1">tz</span>)
    <span class="pl-k">return</span> <span class="pl-c1">0</span>
}</pre></div>
<p>В случаи, если нас не интересует само значение, а лишь его наличие, то можно использовать <strong>пустой идентификатор <code class="notranslate">_</code></strong>, расположенный вместо значения.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">_</span> , <span class="pl-s1">present</span> <span class="pl-c1">:=</span> <span class="pl-s1">timeZone</span>[<span class="pl-s1">tz</span>]</pre></div>
<p>Для удаления записи из карты, необходимо использовать встроенную функцию <code class="notranslate">delete</code>, где в качестве аргументов задаётся карта и ключ для удаления.<br/>
Данная операция безопасна, даже если данного ключа уже нет в карте.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-en">delete</span>(<span class="pl-s1">timeZone</span>, <span class="pl-s">&#34;PDT&#34;</span>)  <span class="pl-c">// Now on Standard Time</span></pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="MKcrIgJNQYmbaYdX">Печать(Printing)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Форматированная печать в Go подобна стилю в языке C <code class="notranslate">printf</code>, но более богаче и более обобщенное. Необходимые функции расположены в пакете <code class="notranslate">fmt</code> и имеют названия с большой буквы: <code class="notranslate">fmt.Printf</code>, <code class="notranslate">fmt.Fprintf</code>, <code class="notranslate">fmt.Sprintf</code> и так далее.  Функции (<code class="notranslate">Sprintf</code> и другие) возвращают строку, а не заполняют предоставленный буфер.</p>
<p>Вам нет необходимости в создании форматировании строк, так как для каждой  <code class="notranslate">Printf</code>, <code class="notranslate">Fprintf</code> and <code class="notranslate">Sprintf</code> есть пара функций к примеру <code class="notranslate">Print</code> и <code class="notranslate">Println</code>.</p>
<p>Данные функции не берут формат строки, а вместо этого устанавливают форматирование по умолчанию для каждого аргумента. Функция <code class="notranslate">Println</code> также добавляет пробел между аргументами и добавляет разрыв строки в конце строки. Функция <code class="notranslate">Print</code> добавляет пробел только той же строке.<br/>
В примере каждая строка производит одинаковый результат.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;Hello %d<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-c1">23</span>)
<span class="pl-s1">fmt</span>.<span class="pl-en">Fprint</span>(<span class="pl-s1">os</span>.<span class="pl-c1">Stdout</span>, <span class="pl-s">&#34;Hello &#34;</span>, <span class="pl-c1">23</span>, <span class="pl-s">&#34;<span class="pl-cce">\n</span>&#34;</span>)
<span class="pl-s1">fmt</span>.<span class="pl-en">Println</span>(<span class="pl-s">&#34;Hello&#34;</span>, <span class="pl-c1">23</span>)
<span class="pl-s1">fmt</span>.<span class="pl-en">Println</span>(<span class="pl-s1">fmt</span>.<span class="pl-en">Sprint</span>(<span class="pl-s">&#34;Hello &#34;</span>, <span class="pl-c1">23</span>))</pre></div>
<p>Для форматированной печати функцией <code class="notranslate">fmt.Fprint</code> и его друзьями, принимают в качестве первого аргумента объект реализующий интерфейс <code class="notranslate">io.Writer</code>.<br/>
Значения <code class="notranslate">os.Stdout</code> и <code class="notranslate">os.Stderr</code> знакомы.</p>
<p>Следующее расходится с реализацией на языке С. Первое, числовые форматы <code class="notranslate">%d</code> не имеют флагов знаковости или размера; Вместо этого, функции печати используют тип аргумента для задания свойств.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">var</span> <span class="pl-s1">x</span> <span class="pl-smi">uint64</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span><span class="pl-c1">&lt;&lt;</span><span class="pl-c1">64</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>
<span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;%d %x; %d %x<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">x</span>, <span class="pl-s1">x</span>, <span class="pl-en">int64</span>(<span class="pl-s1">x</span>), <span class="pl-en">int64</span>(<span class="pl-s1">x</span>))</pre></div>
<p>печатает</p>
<pre class="notranslate"><code class="notranslate">18446744073709551615 ffffffffffffffff; -1 -1
</code></pre>
<p>Если вы используете соглашение по умолчанию, то для целых чисел можно использовать обобщенный формат <code class="notranslate">%v</code> (для &#34;значений&#34;); и результат будет одинаков как для  <code class="notranslate">Print</code> так и для <code class="notranslate">Println</code>.</p>
<p>Более того, данный формат может напечатать <em>любое</em> значение, даже срез, структуру или карту.<br/>
Печать карты временной зоны из предыдущего раздела.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;%v<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">timeZone</span>)  <span class="pl-c">// or just fmt.Println(timeZone)</span></pre></div>
<p>который печатает следующий результат</p>
<pre class="notranslate"><code class="notranslate">map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200]
</code></pre>
<p>Ключи карт могут быть напечатаны в любом порядке.<br/>
При печати структуры, с аннотацией <code class="notranslate">%+v</code> производиться печать полей структуры с их именами и для каждого значения с форматом <code class="notranslate">%#v</code> печатается значение с полным синтаксисом Go.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">T</span> <span class="pl-k">struct</span> {
    <span class="pl-c1">a</span> <span class="pl-smi">int</span>
    <span class="pl-c1">b</span> <span class="pl-smi">float64</span>
    <span class="pl-c1">c</span> <span class="pl-smi">string</span>
}
<span class="pl-s1">t</span> <span class="pl-c1">:=</span> <span class="pl-c1">&amp;</span><span class="pl-smi">T</span>{ <span class="pl-c1">7</span>, <span class="pl-c1">-</span><span class="pl-c1">2.35</span>, <span class="pl-s">&#34;abc<span class="pl-cce">\t</span>def&#34;</span> }
<span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;%v<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">t</span>)
<span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;%+v<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">t</span>)
<span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;%#v<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">t</span>)
<span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;%#v<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">timeZone</span>)</pre></div>
<p>печатает</p>
<pre class="notranslate"><code class="notranslate">&amp;{7 -2.35 abc   def}
&amp;{a:7 b:-2.35 c:abc     def}
&amp;main.T{a:7, b:-2.35, c:&#34;abc\tdef&#34;}
map[string] int{&#34;CST&#34;:-21600, &#34;PST&#34;:-28800, &#34;EST&#34;:-18000, &#34;UTC&#34;:0, &#34;MST&#34;:-25200}
</code></pre>
<p>(На заметку: обратите внимание на амперсанды)</p>
<p>Для ссылок на строки подходит <code class="notranslate">%q</code>, который принимает значение на <code class="notranslate">string</code> или <code class="notranslate">[]byte</code>.<br/>
Альтернативный формат <code class="notranslate">%#q</code> будет использовать обратные кавычки, если это возможно.<br/>
(Формат <code class="notranslate">%q</code> также допустим для целых чисел и рун, создавая односсылочные константы рун.)<br/>
Также, <code class="notranslate">%x</code> работает со строками, массивом байт и срезом байт также как с целыми числами, создаёт шестнадцатеричные целые строки, а с пробелом в формате (<code class="notranslate">% x</code>) добавляет пробелы между байтами.</p>
<p>Другой удобный формат <code class="notranslate">%T</code>, который печатает <em>тип</em> значения.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;%T<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">timeZone</span>)</pre></div>
<p>печатает</p>
<pre class="notranslate"><code class="notranslate">map[string] int
</code></pre>
<p>Если Вы хотите свой собственный формат типа, то для этого достаточно метод с сигнатурой <code class="notranslate">String() string</code> для Вашего типа.<br/>
Для нашего простого примера, тип <code class="notranslate">T</code>, выглядит следующим образом.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> (<span class="pl-s1">t</span> <span class="pl-c1">*</span> <span class="pl-smi">T</span>) <span class="pl-en">String</span>() <span class="pl-smi">string</span> {
    <span class="pl-k">return</span> <span class="pl-s1">fmt</span>.<span class="pl-en">Sprintf</span>(<span class="pl-s">&#34;%d/%g/%q&#34;</span>, <span class="pl-s1">t</span>.<span class="pl-c1">a</span>, <span class="pl-s1">t</span>.<span class="pl-c1">b</span>, <span class="pl-s1">t</span>.<span class="pl-c1">c</span>)
}
<span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;%v<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">t</span>)</pre></div>
<p>Печатает в следующем формате</p>
<pre class="notranslate"><code class="notranslate">7/-2.35/&#34;abc\tdef&#34;
</code></pre>
<p>(Если Вам необходимо напечатать <em>значение</em> типа <code class="notranslate">T</code> как указателя на тип <code class="notranslate">T</code>, то метод <code class="notranslate">String</code> должен иметь значение типа; этот пример использует указатель, т.к. они более эффективны и идиоматичны типу структуры.)</p>
<p>Наша функция <code class="notranslate">String</code> может вызывать <code class="notranslate">Sprintf</code>, потому что функция печати возвращаемая и поэтому можно её обернуть. Это важно для понимания данного подхода.<br/>
Однако, не создавайте функцию <code class="notranslate">String</code> вызывающую метод <code class="notranslate">Sprintf</code>, в случаи если далее будет рекурсивно вызвана <code class="notranslate">String</code>.<br/>
Это может произойти если <code class="notranslate">Sprintf</code> вызывает на печать строку получателя, который вызовет функцию снова. Эту ошибку можно легко создать и она показана на следующем примере.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">MyString</span> <span class="pl-smi">string</span>

<span class="pl-k">func</span> (<span class="pl-s1">m</span> <span class="pl-smi">MyString</span>) <span class="pl-en">String</span>() <span class="pl-smi">string</span> {
    <span class="pl-k">return</span> <span class="pl-s1">fmt</span>.<span class="pl-en">Sprintf</span>(<span class="pl-s">&#34;MyString=%s&#34;</span>, <span class="pl-s1">m</span>) <span class="pl-c">// Error: will recur forever.</span>
}</pre></div>
<p>Для того чтобы решить эту проблему, необходимо изменить аргумент на базовый тип, который не имеет функции.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">MyString</span> <span class="pl-smi">string</span>
<span class="pl-k">func</span> (<span class="pl-s1">m</span> <span class="pl-smi">MyString</span>) <span class="pl-en">String</span>() <span class="pl-smi">string</span> {
    <span class="pl-k">return</span> <span class="pl-s1">fmt</span>.<span class="pl-en">Sprintf</span>(<span class="pl-s">&#34;MyString=%s&#34;</span>, <span class="pl-en">string</span>(<span class="pl-s1">m</span>)) <span class="pl-c">// OK: note conversion.</span>
}</pre></div>
<p>Другой способ печати это допустить печать функции аргументов напрямую в другую функцию.<br/>
Сигнатура <code class="notranslate">Printf</code> используется для типов <code class="notranslate">...interface{}</code>, что допускает произвольное число аргументов, которые добавляются после формата <em>format</em>.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">Printf</span>(<span class="pl-s1">format</span> <span class="pl-smi">string</span>, <span class="pl-s1">v</span> <span class="pl-c1">...</span><span class="pl-k">interface</span>{}) (<span class="pl-s1">n</span> <span class="pl-smi">int</span>, <span class="pl-s1">err</span> <span class="pl-smi">error</span>) {</pre></div>
<p><strong>TODO</strong><br/>
Within the function <code class="notranslate">Printf</code>, <code class="notranslate">v</code> acts like a variable of type <code class="notranslate">[]interface{}</code> but if it is passed to another variadic function, it acts like a regular list of arguments.<br/>
Here is the implementation of the function <code class="notranslate">log.Println</code> we used above. It passes  its arguments directly to <code class="notranslate">fmt.Sprintln</code> for the actual formatting.<br/>
<strong>-</strong></p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// Println prints to the standard logger in the manner of fmt.Println.</span>
<span class="pl-k">func</span> <span class="pl-en">Println</span>(<span class="pl-s1">v</span> <span class="pl-c1">...</span><span class="pl-k">interface</span>{}) {
    <span class="pl-s1">std</span>.<span class="pl-en">Output</span>(<span class="pl-c1">2</span>, <span class="pl-s1">fmt</span>.<span class="pl-en">Sprintln</span>(<span class="pl-s1">v</span><span class="pl-c1">...</span>))  <span class="pl-c">// Output takes parameters (int, string)</span>
}</pre></div>
<p>Запись <code class="notranslate">...</code> после <code class="notranslate">v</code> при вызове функции <code class="notranslate">Sprintln</code> объявляет компилятору о том что <code class="notranslate">v</code> является списком аргументов; с другой стороны <code class="notranslate">v</code> воспринимается как простой срез аргументов.</p>
<p>Если Вам необходимо большее количество информации, то смотрите документацию <code class="notranslate">godoc</code> в пакете <code class="notranslate">fmt</code>.</p>
<p>Кстати параметр <code class="notranslate">...</code> может иметь тип, для примера<code class="notranslate">...int</code> для функции определения минимума используется список целых чисел:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">Min</span>(<span class="pl-s1">a</span> <span class="pl-c1">...</span><span class="pl-smi">int</span>) <span class="pl-smi">int</span> {
    <span class="pl-s1">min</span> <span class="pl-c1">:=</span> <span class="pl-en">int</span>(<span class="pl-c1">^</span><span class="pl-en">uint</span>(<span class="pl-c1">0</span>) <span class="pl-c1">&gt;&gt;</span> <span class="pl-c1">1</span>)  <span class="pl-c">// largest int</span>
    <span class="pl-k">for</span> <span class="pl-s1">_</span> , <span class="pl-s1">i</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-s1">a</span> {
        <span class="pl-k">if</span> <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">min</span> {
            <span class="pl-s1">min</span> <span class="pl-c1">=</span> <span class="pl-s1">i</span>
        }
    }
    <span class="pl-k">return</span> <span class="pl-s1">min</span>
}</pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="ZBNJtTNiQhWCyijm">Присоединение(Append)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>В настоящий момент? пришел момент для разъяснения конструкции встроенной функции <code class="notranslate">append</code>. Сигнатура функции <code class="notranslate">append</code> отличается от ранее описанной функции <code class="notranslate">Append</code>.<br/>
Схематично, выглядит следующим образом:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">append</span>(<span class="pl-s1">slice</span> []<span class="pl-c1">*</span><span class="pl-smi">T</span><span class="pl-c1">*</span>, <span class="pl-s1">elements</span> <span class="pl-c1">...</span><span class="pl-c1">*</span><span class="pl-smi">T</span><span class="pl-c1">*</span>) []<span class="pl-c1">*</span><span class="pl-smi">T</span><span class="pl-c1">*</span></pre></div>
<p>где <em>T</em> любой тип. Вы не можете написать в языке Go функцию в которой <code class="notranslate">T</code> определена вызывающим. Поэтому необходима поддержка компилятора для функции <code class="notranslate">append</code>.</p>
<p>Данная функция <code class="notranslate">append</code> добавляет элемент в конец среза и возвращает результат.<br/>
Причина возврата результата, в том что как и в рукописной функции <code class="notranslate">Append</code> массив может измениться.<br/>
Простой пример:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">x</span> <span class="pl-c1">:=</span> []<span class="pl-smi">int</span>{<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>}
<span class="pl-s1">x</span> <span class="pl-c1">=</span> <span class="pl-en">append</span>(<span class="pl-s1">x</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>)
<span class="pl-s1">fmt</span>.<span class="pl-en">Println</span>(<span class="pl-s1">x</span>)</pre></div>
<p>печатает <code class="notranslate">[1 2 3 4 5 6]</code>.  Итак, <code class="notranslate">append</code> работает в принципе как <code class="notranslate">Printf</code> с произвольным количеством аргументов.</p>
<p>Но что если необходимо добавить срез в срез, как в нашей реализации <code class="notranslate">Append</code>? Все просто: используем <code class="notranslate">...</code> который мы использовали в <code class="notranslate">Output</code>. Вот пример кода для получение того же результата.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">x</span> <span class="pl-c1">:=</span> []<span class="pl-smi">int</span>{<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>}
<span class="pl-s1">y</span> <span class="pl-c1">:=</span> []<span class="pl-smi">int</span>{<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>}
<span class="pl-s1">x</span> <span class="pl-c1">=</span> <span class="pl-en">append</span>(<span class="pl-s1">x</span>, <span class="pl-s1">y</span><span class="pl-c1">...</span>)
<span class="pl-s1">fmt</span>.<span class="pl-en">Println</span>(<span class="pl-s1">x</span>)</pre></div>
<p>Обращаю внимание, что без <code class="notranslate">...</code> компилятор напишет ошибку, так как <code class="notranslate">y</code> не имеет тип <code class="notranslate">int</code>.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h2 id="qddebmeoqxyfgJZI">Инициализация(Initialization)</h2>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Инициализация в языке Go более мощный инструмент нежели в языках С или С++.<br/>
Даже сложные структуры можно инициализировать. Упорядочивание между инициализируемыми объектами разных пакетов, обрабатывается корректно.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="fKNXnmDOUSNsmWpX">Константы(Constants)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Константы в Go это просто константы.<br/>
Они создаются во время компиляции даже если она определена в локальной функции и могут быть цифры, символы(руны), строки или булевый тип.<br/>
Из-за ограничения времени компиляции, компилятор должен определять какие выражения могут быть константами. К примеру, выражение <code class="notranslate">1&lt;&lt;3</code>  это константное выражение, в то время как выражение <code class="notranslate">math.Sin(math.Pi/4)</code> не является константой, так как вызывает функцию <code class="notranslate">math.Sin</code> требующую выполнения по время выполнения.</p>
<p>В языке Go, перечисление констант производиться с помощью перечислителя <strong><code class="notranslate">iota</code></strong>. Так как <code class="notranslate">iota</code> может быть неявно повторяемой для выражения или выражений, то легко можно строить сложные наборы значений.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">//{{code &#34;/doc/progs/eff_bytesize.go&#34; `/^type ByteSize/` `/^\)/`}}</span>
<span class="pl-c">// Copyright 2009 The Go Authors. All rights reserved.</span>
<span class="pl-c">// Use of this source code is governed by a BSD-style</span>
<span class="pl-c">// license that can be found in the LICENSE file.</span>

<span class="pl-k">package</span> main

<span class="pl-k">import</span> <span class="pl-s">&#34;fmt&#34;</span>

<span class="pl-k">type</span> <span class="pl-smi">ByteSize</span> <span class="pl-smi">float64</span>

<span class="pl-k">const</span> (
	<span class="pl-s1">_</span>           <span class="pl-c1">=</span> <span class="pl-s1">iota</span> <span class="pl-c">// ignore first value by assigning to blank identifier</span>
	<span class="pl-s1">KB</span> <span class="pl-smi">ByteSize</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span> <span class="pl-c1">&lt;&lt;</span> (<span class="pl-c1">10</span> <span class="pl-c1">*</span> <span class="pl-s1">iota</span>)
	<span class="pl-s1">MB</span>
	<span class="pl-s1">GB</span>
	<span class="pl-s1">TB</span>
	<span class="pl-s1">PB</span>
	<span class="pl-s1">EB</span>
	<span class="pl-s1">ZB</span>
	<span class="pl-s1">YB</span>
)</pre></div>
<p>Использование функции <code class="notranslate">String</code> к пользовательским типам производить печать необходимым образом.<br/>
<strong>TODO</strong><br/>
Although you&#39;ll see it most often applied to structs, this technique is also useful for scalar types such as floating-point types like <code class="notranslate">ByteSize</code>.<br/>
<strong>-</strong></p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">//See code &#34;/doc/progs/eff_bytesize.go&#34;</span>

<span class="pl-k">func</span> (<span class="pl-s1">b</span> <span class="pl-smi">ByteSize</span>) <span class="pl-en">String</span>() <span class="pl-smi">string</span> {
	<span class="pl-k">switch</span> {
	<span class="pl-k">case</span> <span class="pl-s1">b</span> <span class="pl-c1">&gt;=</span> <span class="pl-s1">YB</span>:
		<span class="pl-k">return</span> <span class="pl-s1">fmt</span>.<span class="pl-en">Sprintf</span>(<span class="pl-s">&#34;%.2fYB&#34;</span>, <span class="pl-s1">b</span><span class="pl-c1">/</span><span class="pl-s1">YB</span>)
	<span class="pl-k">case</span> <span class="pl-s1">b</span> <span class="pl-c1">&gt;=</span> <span class="pl-s1">ZB</span>:
		<span class="pl-k">return</span> <span class="pl-s1">fmt</span>.<span class="pl-en">Sprintf</span>(<span class="pl-s">&#34;%.2fZB&#34;</span>, <span class="pl-s1">b</span><span class="pl-c1">/</span><span class="pl-s1">ZB</span>)
	<span class="pl-k">case</span> <span class="pl-s1">b</span> <span class="pl-c1">&gt;=</span> <span class="pl-s1">EB</span>:
		<span class="pl-k">return</span> <span class="pl-s1">fmt</span>.<span class="pl-en">Sprintf</span>(<span class="pl-s">&#34;%.2fEB&#34;</span>, <span class="pl-s1">b</span><span class="pl-c1">/</span><span class="pl-s1">EB</span>)
	<span class="pl-k">case</span> <span class="pl-s1">b</span> <span class="pl-c1">&gt;=</span> <span class="pl-s1">PB</span>:
		<span class="pl-k">return</span> <span class="pl-s1">fmt</span>.<span class="pl-en">Sprintf</span>(<span class="pl-s">&#34;%.2fPB&#34;</span>, <span class="pl-s1">b</span><span class="pl-c1">/</span><span class="pl-s1">PB</span>)
	<span class="pl-k">case</span> <span class="pl-s1">b</span> <span class="pl-c1">&gt;=</span> <span class="pl-s1">TB</span>:
		<span class="pl-k">return</span> <span class="pl-s1">fmt</span>.<span class="pl-en">Sprintf</span>(<span class="pl-s">&#34;%.2fTB&#34;</span>, <span class="pl-s1">b</span><span class="pl-c1">/</span><span class="pl-s1">TB</span>)
	<span class="pl-k">case</span> <span class="pl-s1">b</span> <span class="pl-c1">&gt;=</span> <span class="pl-s1">GB</span>:
		<span class="pl-k">return</span> <span class="pl-s1">fmt</span>.<span class="pl-en">Sprintf</span>(<span class="pl-s">&#34;%.2fGB&#34;</span>, <span class="pl-s1">b</span><span class="pl-c1">/</span><span class="pl-s1">GB</span>)
	<span class="pl-k">case</span> <span class="pl-s1">b</span> <span class="pl-c1">&gt;=</span> <span class="pl-s1">MB</span>:
		<span class="pl-k">return</span> <span class="pl-s1">fmt</span>.<span class="pl-en">Sprintf</span>(<span class="pl-s">&#34;%.2fMB&#34;</span>, <span class="pl-s1">b</span><span class="pl-c1">/</span><span class="pl-s1">MB</span>)
	<span class="pl-k">case</span> <span class="pl-s1">b</span> <span class="pl-c1">&gt;=</span> <span class="pl-s1">KB</span>:
		<span class="pl-k">return</span> <span class="pl-s1">fmt</span>.<span class="pl-en">Sprintf</span>(<span class="pl-s">&#34;%.2fKB&#34;</span>, <span class="pl-s1">b</span><span class="pl-c1">/</span><span class="pl-s1">KB</span>)
	}
	<span class="pl-k">return</span> <span class="pl-s1">fmt</span>.<span class="pl-en">Sprintf</span>(<span class="pl-s">&#34;%.2fB&#34;</span>, <span class="pl-s1">b</span>)
}</pre></div>
<p>Выражение <code class="notranslate">YB</code> печатается как <code class="notranslate">1.00YB</code>, когда <code class="notranslate">ByteSize(1e13)</code> печатает как <code class="notranslate">9.09TB</code>.</p>
<p>Используемый здесь <code class="notranslate">Sprintf</code> в функции <code class="notranslate">String</code> типа <code class="notranslate">ByteSize</code> безопасна(не вызывается рекурсивно), не потому что происходит конвертирование, а потому что вызывается функция <code class="notranslate">Sprintf</code> с <code class="notranslate">%f</code>, который не строковый формат:<code class="notranslate">Sprintf</code> будет вызывать функцию <code class="notranslate">String</code>, функцию которой необходима строка и <code class="notranslate">%f</code> число с плавающей точкой.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="wprodZIMlHjcrsGH">Переменные(Variables)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Переменные могут инициализироваться как константы, но инициализация производиться во время работы.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">var</span> (
    <span class="pl-s1">home</span>   <span class="pl-c1">=</span> <span class="pl-s1">os</span>.<span class="pl-en">Getenv</span>(<span class="pl-s">&#34;HOME&#34;</span>)
    <span class="pl-s1">user</span>   <span class="pl-c1">=</span> <span class="pl-s1">os</span>.<span class="pl-en">Getenv</span>(<span class="pl-s">&#34;USER&#34;</span>)
    <span class="pl-s1">gopath</span> <span class="pl-c1">=</span> <span class="pl-s1">os</span>.<span class="pl-en">Getenv</span>(<span class="pl-s">&#34;GOPATH&#34;</span>)
)</pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="YUnDPbuAfwknQXpx">Функция init</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Каждый исходный код может определить свою первичную функцию <code class="notranslate">init</code> для обязательных  настройки. (На самом деле файл может иметь несколько функций <code class="notranslate">init</code>.)<br/>
Функция <code class="notranslate">init</code> вызывается после всех объявлений переменных и после всех объявлений переменных всех пакетов.</p>
<p>Общее применение функции <code class="notranslate">init</code> в проверки или починки состояния программы до начала реального исполнения.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">init</span>() {
    <span class="pl-k">if</span> <span class="pl-s1">user</span> <span class="pl-c1">==</span> <span class="pl-s">&#34;&#34;</span> {
        <span class="pl-s1">log</span>.<span class="pl-en">Fatal</span>(<span class="pl-s">&#34;$USER not set&#34;</span>)
    }
    <span class="pl-k">if</span> <span class="pl-s1">home</span> <span class="pl-c1">==</span> <span class="pl-s">&#34;&#34;</span> {
        <span class="pl-s1">home</span> <span class="pl-c1">=</span> <span class="pl-s">&#34;/home/&#34;</span> <span class="pl-c1">+</span> <span class="pl-s1">user</span>
    }
    <span class="pl-k">if</span> <span class="pl-s1">gopath</span> <span class="pl-c1">==</span> <span class="pl-s">&#34;&#34;</span> {
        <span class="pl-s1">gopath</span> <span class="pl-c1">=</span> <span class="pl-s1">home</span> <span class="pl-c1">+</span> <span class="pl-s">&#34;/go&#34;</span>
    }
    <span class="pl-c">// gopath may be overridden by --gopath flag on command line.</span>
    <span class="pl-s1">flag</span>.<span class="pl-en">StringVar</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">gopath</span>, <span class="pl-s">&#34;gopath&#34;</span>, <span class="pl-s1">gopath</span>, <span class="pl-s">&#34;override default GOPATH&#34;</span>)
}</pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h2 id="GXlCqDuXrAdqEcqc">Методы(Methods)</h2>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="AaUTRJqzrurdLTMo">Указатели или Значения</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Как мы видели в примеры с <code class="notranslate">ByteSize</code>, функции может иметь имя типа (кроме указателей или интерфейсов) и приемник не обязательно должен иметь структуры.</p>
<p>Как обсуждалось ранее в срезах, мы написали функцию <code class="notranslate">Append</code>.<br/>
Мы можем определить функции вместе со срезом. Для этого, мы объявим именованный тип, который мы можем связать с функцией и там самым создать получателя данной функции для значений этого типа.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">ByteSlice</span> []<span class="pl-smi">byte</span>

<span class="pl-k">func</span> (<span class="pl-s1">slice</span> <span class="pl-smi">ByteSlice</span>) <span class="pl-en">Append</span>(<span class="pl-s1">data</span> []<span class="pl-smi">byte</span>) []<span class="pl-smi">byte</span> {
    <span class="pl-c">// Body exactly the same as the Append function defined above.</span>
}</pre></div>
<p>Данный метод все также возвращает обновленный срез. Для решения этой неуклюжести можно воспользоваться <em>указателем</em> на <code class="notranslate">ByteSize</code> в получатель, итак можно переписать следующим образом:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> (<span class="pl-s1">p</span> <span class="pl-c1">*</span><span class="pl-smi">ByteSlice</span>) <span class="pl-en">Append</span>(<span class="pl-s1">data</span> []<span class="pl-smi">byte</span>) {
    <span class="pl-s1">slice</span> <span class="pl-c1">:=</span> <span class="pl-c1">*</span><span class="pl-s1">p</span>
    <span class="pl-c">// Body as above, without the return.</span>
    <span class="pl-c1">*</span><span class="pl-s1">p</span> <span class="pl-c1">=</span> <span class="pl-s1">slice</span>
}</pre></div>
<p>На самом деле, мы можем сделать это ещё лучше. Если мы изменим функцию, то она будет выглядеть как стандартная функция <code class="notranslate">Write</code>, то есть вот так,</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> (<span class="pl-s1">p</span> <span class="pl-c1">*</span><span class="pl-smi">ByteSlice</span>) <span class="pl-en">Write</span>(<span class="pl-s1">data</span> []<span class="pl-smi">byte</span>) (<span class="pl-s1">n</span> <span class="pl-smi">int</span>, <span class="pl-s1">err</span> <span class="pl-smi">error</span>) {
    <span class="pl-s1">slice</span> <span class="pl-c1">:=</span> <span class="pl-c1">*</span><span class="pl-s1">p</span>
    <span class="pl-c">// Again as above.</span>
    <span class="pl-c1">*</span><span class="pl-s1">p</span> <span class="pl-c1">=</span> <span class="pl-s1">slice</span>
    <span class="pl-k">return</span> <span class="pl-en">len</span>(<span class="pl-s1">data</span>), <span class="pl-c1">nil</span>
}</pre></div>
<p>тип <code class="notranslate">*ByteSlice</code> удовлетворяет стандартному интерфейсу <code class="notranslate">io.Writer</code>, что удобно. Например, мы можем напечатать один из них:</p>
<div class="highlight highlight-source-go"><pre class="notranslate">    <span class="pl-k">var</span> <span class="pl-s1">b</span> <span class="pl-smi">ByteSlice</span>
    <span class="pl-s1">fmt</span>.<span class="pl-en">Fprintf</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">b</span>, <span class="pl-s">&#34;This hour has %d days<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-c1">7</span>)</pre></div>
<p>Мы передаем адрес <code class="notranslate">ByteSlice</code>, поскольку только <code class="notranslate">*ByteSlice</code> удовлетворяет интерфейсу <code class="notranslate">io.Writer</code>.<br/>
Правило получателя <em>о указателях или значениях</em>, в том что функции значения могут использоваться для указателей и значений, а функция указателя может только использовать указатель.</p>
<p>Это правило возникло потому что функции указателя могут изменять получателя.<br/>
Вызывая значение в функции значений получаешь копию значения, поэтому никаких модификаций не произойдет.<br/>
Поэтому язык запрещает эту ошибку.<br/>
Когда адресуется значение, то язык заботится о подставлении символа адресации автоматически.</p>
<p>К примеру, переменная <code class="notranslate">b</code> адресованная, поэтому мы можем вызвать функцию <code class="notranslate">Write</code> просто вызвав <code class="notranslate">b.Write</code>.<br/>
Компилятор сам допишет <code class="notranslate">(&amp;b).Write</code> за нас.</p>
<p>Кстати, идея использования <code class="notranslate">Write</code> на срезах байт наиважнейшая для реализации <code class="notranslate">bytes.Buffer</code>.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h2 id="kAMiahjhSMpZdYKb">Интерфейсы и другие типы</h2>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="IkmWBdTuGSpgQpHd">Интерфейсы</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Интерфейсы в Go позволяют создать особое поведения для объектов: <em>Если нечто может делать</em> <strong>это</strong> <em>, то это можно использовать</em> <strong>здесь</strong>. Мы уже это встречали в простых примерах, когда реализовывали функцию <code class="notranslate">String</code> для печати, в то время как <code class="notranslate">Fprintf</code> может выдавать на печать другое с методом <code class="notranslate">Write</code>.<br/>
Интерфейсы с одним или двумя функциями свойственны в языке Go, как <code class="notranslate">io.Writer</code> реализующий <code class="notranslate">Write</code>.</p>
<p>Любой тип может реализовывать множество интерфейсов.<br/>
К примеру, коллекции могут быть отсортированы с помощью функций из пакета <code class="notranslate">sort</code>, если она реализует <code class="notranslate">sort.Interface</code>, который состоит из <code class="notranslate">Len()</code>, <code class="notranslate">Less(i, j int) bool</code>, и <code class="notranslate">Swap(i, j int)</code> и это может задать собственный формат.<br/>
Рассмотрим пример <code class="notranslate">Sequence</code></p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">//{{code &#34;/doc/progs/eff_sequence.go&#34; `/^type/` &#34;$&#34;}}</span>
<span class="pl-c">// Copyright 2009 The Go Authors. All rights reserved.</span>
<span class="pl-c">// Use of this source code is governed by a BSD-style</span>
<span class="pl-c">// license that can be found in the LICENSE file.</span>

<span class="pl-k">package</span> main

<span class="pl-k">import</span> (
	<span class="pl-s">&#34;fmt&#34;</span>
	<span class="pl-s">&#34;sort&#34;</span>
)

<span class="pl-k">func</span> <span class="pl-en">main</span>() {
	<span class="pl-s1">seq</span> <span class="pl-c1">:=</span> <span class="pl-smi">Sequence</span>{<span class="pl-c1">6</span>, <span class="pl-c1">2</span>, <span class="pl-c1">-</span><span class="pl-c1">1</span>, <span class="pl-c1">44</span>, <span class="pl-c1">16</span>}
	<span class="pl-s1">sort</span>.<span class="pl-en">Sort</span>(<span class="pl-s1">seq</span>)
	<span class="pl-s1">fmt</span>.<span class="pl-en">Println</span>(<span class="pl-s1">seq</span>)
}

<span class="pl-k">type</span> <span class="pl-smi">Sequence</span> []<span class="pl-smi">int</span>

<span class="pl-c">// Methods required by sort.Interface.</span>
<span class="pl-k">func</span> (<span class="pl-s1">s</span> <span class="pl-smi">Sequence</span>) <span class="pl-en">Len</span>() <span class="pl-smi">int</span> {
	<span class="pl-k">return</span> <span class="pl-en">len</span>(<span class="pl-s1">s</span>)
}
<span class="pl-k">func</span> (<span class="pl-s1">s</span> <span class="pl-smi">Sequence</span>) <span class="pl-en">Less</span>(<span class="pl-s1">i</span>, <span class="pl-s1">j</span> <span class="pl-smi">int</span>) <span class="pl-smi">bool</span> {
	<span class="pl-k">return</span> <span class="pl-s1">s</span>[<span class="pl-s1">i</span>] <span class="pl-c1">&lt;</span> <span class="pl-s1">s</span>[<span class="pl-s1">j</span>]
}
<span class="pl-k">func</span> (<span class="pl-s1">s</span> <span class="pl-smi">Sequence</span>) <span class="pl-en">Swap</span>(<span class="pl-s1">i</span>, <span class="pl-s1">j</span> <span class="pl-smi">int</span>) {
	<span class="pl-s1">s</span>[<span class="pl-s1">i</span>], <span class="pl-s1">s</span>[<span class="pl-s1">j</span>] <span class="pl-c1">=</span> <span class="pl-s1">s</span>[<span class="pl-s1">j</span>], <span class="pl-s1">s</span>[<span class="pl-s1">i</span>]
}

<span class="pl-c">// Method for printing - sorts the elements before printing.</span>
<span class="pl-k">func</span> (<span class="pl-s1">s</span> <span class="pl-smi">Sequence</span>) <span class="pl-en">String</span>() <span class="pl-smi">string</span> {
	<span class="pl-s1">sort</span>.<span class="pl-en">Sort</span>(<span class="pl-s1">s</span>)
	<span class="pl-s1">str</span> <span class="pl-c1">:=</span> <span class="pl-s">&#34;[&#34;</span>
	<span class="pl-k">for</span> <span class="pl-s1">i</span>, <span class="pl-s1">elem</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-s1">s</span> {
		<span class="pl-k">if</span> <span class="pl-s1">i</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">0</span> {
			<span class="pl-s1">str</span> <span class="pl-c1">+=</span> <span class="pl-s">&#34; &#34;</span>
		}
		<span class="pl-s1">str</span> <span class="pl-c1">+=</span> <span class="pl-s1">fmt</span>.<span class="pl-en">Sprint</span>(<span class="pl-s1">elem</span>)
	}
	<span class="pl-k">return</span> <span class="pl-s1">str</span> <span class="pl-c1">+</span> <span class="pl-s">&#34;]&#34;</span>
}</pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="lQqGQzrxNaARNDRE">Преобразование (Conversions)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Функция <code class="notranslate">String</code> работает с <code class="notranslate">Sequence</code> и <code class="notranslate">Sprint</code> уже работает со срезами. Мы может распространить данный эффект, если конвертируем  <code class="notranslate">Sequence</code> на  <code class="notranslate">[]int</code> до вызова <code class="notranslate">Sprint</code>.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> (<span class="pl-s1">s</span> <span class="pl-smi">Sequence</span>) <span class="pl-en">String</span>() <span class="pl-smi">string</span> {
    <span class="pl-s1">sort</span>.<span class="pl-en">Sort</span>(<span class="pl-s1">s</span>)
    <span class="pl-k">return</span> <span class="pl-s1">fmt</span>.<span class="pl-en">Sprint</span>([]<span class="pl-smi">int</span>(<span class="pl-s1">s</span>))
}</pre></div>
<p>Это функция другой пример техники конвертирования для вызова <code class="notranslate">Sprintf</code> безопасно для функции <code class="notranslate">String</code>.<br/>
Так как два типа (<code class="notranslate">Sequence</code> и <code class="notranslate">[]int</code>) одинаковы, то мы можем игнорировать имя типа, это допустимое конвертирование между ними.<br/>
При конвертации не происходит создание нового значения, это временная замена существующего значения на новый тип.<br/>
(При других допустимых конвертациях, к примеру из целого числа в число с плавающей точкой, происходит создание нового значения.)</p>
<p>Это идиоматично в программе Go - конвертация типа позволяет получить доступ к другим функциям. К примеру, мы можем использовать существующий тип <code class="notranslate">sort.IntSlice</code>:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">Sequence</span> []<span class="pl-smi">int</span>

<span class="pl-c">// Method for printing - sorts the elements before printing</span>
<span class="pl-k">func</span> (<span class="pl-s1">s</span> <span class="pl-smi">Sequence</span>) <span class="pl-en">String</span>() <span class="pl-smi">string</span> {
    <span class="pl-s1">sort</span>.<span class="pl-en">IntSlice</span>(<span class="pl-s1">s</span>).<span class="pl-en">Sort</span>()
    <span class="pl-k">return</span> <span class="pl-s1">fmt</span>.<span class="pl-en">Sprint</span>([]<span class="pl-smi">int</span>(<span class="pl-s1">s</span>))
}</pre></div>
<p>Теперь, наш <code class="notranslate">Sequence</code> реализует множество интерфейсов (сортировка и печать),  мы можем использовать множество типов (<code class="notranslate">Sequence</code>, <code class="notranslate">sort.IntSlice</code> и <code class="notranslate">[]int</code>), которые выполняют определенную часть работ.<br/>
Это не типично в использовании, но эффективно.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="SpGXsKpDQtgnSFId">Конвертация интерфейсов и привязка типов</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Переключатель типов(Type switches) является одной из форм конвертации: на основе интерфейса и переключателя для каждого элемента, в некотором смысле преобразует тип в элемент переключателя.<br/>
Это простой вариант как в коде <code class="notranslate">fmt.Printf</code> конвертирует значение в строку, используя переключатель типа.<br/>
И если это уже строка, мы хотим чтобы фактическое значение происходило по его интерфейсу, но в случаи если она имеет функцию <code class="notranslate">String</code>, то хотим чтобы в результате вызывалась именно она.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">Stringer</span> <span class="pl-k">interface</span> {
    <span class="pl-c1">String</span>() <span class="pl-smi">string</span>
}

<span class="pl-k">var</span> <span class="pl-s1">value</span> <span class="pl-k">interface</span>{} <span class="pl-c">// Value provided by caller.</span>
<span class="pl-k">switch</span> <span class="pl-s1">str</span> <span class="pl-c1">:=</span> <span class="pl-s1">value</span>.(<span class="pl-k">type</span>) {
<span class="pl-k">case</span> <span class="pl-smi">string</span>:
    <span class="pl-k">return</span> <span class="pl-s1">str</span>
<span class="pl-k">case</span> <span class="pl-smi">Stringer</span>:
    <span class="pl-k">return</span> <span class="pl-s1">str</span>.<span class="pl-en">String</span>()
}</pre></div>
<p>В первом случае ищется конкретное значение, во втором случаи происходит преобразование интерфейса в другой интерфейс.<br/>
Это хороший подход в преобразовании типов.</p>
<p>Что если, мы будем беспокоиться лишь об одном типе? Если мы знаем что значение имеет тип <code class="notranslate">string</code> и мы хотим вытащить только его?<br/>
Можно сделать переключатель только с одним типом, но это будет <em>type assertion</em>.<br/>
И <em>type assertion</em> берет значение интерфейса и переводит из его значения в его тип.<br/>
Заимствование типа из открытия <em>type switch</em>, но переводит тип с помощью ключевого слова <code class="notranslate">type</code>:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">value</span>.(<span class="pl-smi">typeName</span>)</pre></div>
<p>и в результате у нас значение со статическим типом <code class="notranslate">typeName</code>.<br/>
Этот тип должен быть конкретным типом имеющим интерфейс, или второй тип интерфейса - это тип в который может быть конвертирован.<br/>
Если мы знаем что это строка в значении, то мы можем записать:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">str</span> <span class="pl-c1">:=</span> <span class="pl-s1">value</span>.(<span class="pl-smi">string</span>)</pre></div>
<p>Но если выясниться, что значение хранит не строку, то программа будет обрушена во время работы в <em>run-time error</em>.<br/>
Для защиты от этого используется идиома <em>запятая, ок</em> <em>&#34;comma, ok&#34;</em> для безопасности и проверка является ли значение строкой:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">str</span>, <span class="pl-s1">ok</span> <span class="pl-c1">:=</span> <span class="pl-s1">value</span>.(<span class="pl-smi">string</span>)
<span class="pl-k">if</span> <span class="pl-s1">ok</span> {
    <span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;string value is: %q<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">str</span>)
} <span class="pl-k">else</span> {
    <span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;value is not a string<span class="pl-cce">\n</span>&#34;</span>)
}</pre></div>
<p>В случаи неудачи, <code class="notranslate">str</code> будет всё ещё существовать и будет типом строка, но будет иметь нулевое значение - пустую строку.</p>
<p>Для иллюстрации, используем условие <code class="notranslate">if</code>-<code class="notranslate">else</code> как эквивалент переключателя типов <em>type switch</em> в начале этого раздела.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">if</span> <span class="pl-s1">str</span>, <span class="pl-s1">ok</span> <span class="pl-c1">:=</span> <span class="pl-s1">value</span>.(<span class="pl-smi">string</span>); <span class="pl-s1">ok</span> {
    <span class="pl-k">return</span> <span class="pl-s1">str</span>
} <span class="pl-k">else</span> <span class="pl-k">if</span> <span class="pl-s1">str</span>, <span class="pl-s1">ok</span> <span class="pl-c1">:=</span> <span class="pl-s1">value</span>.(<span class="pl-smi">Stringer</span>); <span class="pl-s1">ok</span> {
    <span class="pl-k">return</span> <span class="pl-s1">str</span>.<span class="pl-en">String</span>()
}</pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="DerBvtJJMYovnZaA">Общее(Generality)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Если тип существует только для реализации интерфейса и никогда не будет экспортироваться за пределы интерфейса, то нет необходимости экспортировать сам тип.<br/>
Экспортирование только интерфейса делает более понятным, что значение имеет не так интересно как поведение интерфейса.<br/>
Также это позволяет избегать повторения документации для каждого экземпляра общего метода.</p>
<p>В таких случаях, конструктор может возвращать значение интерфейса, что лучше чем реализованный тип.<br/>
Для примера, в  библиотеках хэш <em>hash</em> оба конструктора <code class="notranslate">crc32.NewIEEE</code> и <code class="notranslate">adler32.New</code> возвращают тип интерфейса <code class="notranslate">hash.Hash32</code>.<br/>
Для подстановки алгоритма CRC-32 для Adler-32 в программе Go требуется только изменить вызов конструктора, а остальная часть кода не зависит от алгоритма.</p>
<p>Подобный подход позволяет создать поток шифровальных алгоритмов помимо имеющихся в пакете <code class="notranslate">crypto</code>, устанавливаются в цепочку отдельно от блока шифрования.<br/>
Интерфейс <code class="notranslate">Block</code> в пакете <code class="notranslate">crypto/cipher</code> имеющий поведение -  шифрование, который обеспечивает шифрование одного блока данных.<br/>
Это по аналогии с пакетом <code class="notranslate">bufio</code>, пакет шифрования реализует этот интерфейс и может использовать конструктор потока шифрования, представляя интерфейс <code class="notranslate">Stream</code> без известных деталей о шифровании.</p>
<p>Интерфейсы <code class="notranslate">crypto/cipher</code> выглядят следующим образом:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">Block</span> <span class="pl-k">interface</span> {
    <span class="pl-c1">BlockSize</span>() <span class="pl-smi">int</span>
    <span class="pl-c1">Encrypt</span>(<span class="pl-s1">src</span>, <span class="pl-s1">dst</span> []<span class="pl-smi">byte</span>)
    <span class="pl-c1">Decrypt</span>(<span class="pl-s1">src</span>, <span class="pl-s1">dst</span> []<span class="pl-smi">byte</span>)
}

<span class="pl-k">type</span> <span class="pl-smi">Stream</span> <span class="pl-k">interface</span> {
    <span class="pl-c1">XORKeyStream</span>(<span class="pl-s1">dst</span>, <span class="pl-s1">src</span> []<span class="pl-smi">byte</span>)
}</pre></div>
<p>Определение режима счётчика потока <em>counter mode (CTR) stream</em>, который превращает блоки шифрования в поток шифрования, обратите внимание, что шифрование блоков абстрагировано:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// NewCTR returns a Stream that encrypts/decrypts using the given Block in</span>
<span class="pl-c">// counter mode. The length of iv must be the same as the Block&#39;s block size.</span>
<span class="pl-k">func</span> <span class="pl-en">NewCTR</span>(<span class="pl-s1">block</span> <span class="pl-smi">Block</span>, <span class="pl-s1">iv</span> []<span class="pl-smi">byte</span>) <span class="pl-smi">Stream</span></pre></div>
<p>Принятое <code class="notranslate">NewCTR</code> не только для одного конкретного алгоритма шифрования и исходных данных, но для любой реализации интерфейса <code class="notranslate">Block</code> и любой <code class="notranslate">Stream</code>.<br/>
Так как он возвращает тип интерфейса, замена шифрование CTR с другими режимами шифрования это локальное изменение. Вызов конструктора должен быть отредактирован, и при этом окружающий код не заметит разницы , так как в результате <code class="notranslate">Stream</code>.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="gYdHydlVVHoKlSNP">Интерфейсы и методы(функции)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Так как метод может иметь почти всё, поэтому все можно удовлетворить интерфейсами.<br/>
Один из примеров из пакета <code class="notranslate">http</code>, который имеет интерфейс <code class="notranslate">Handler</code>. Любой объект реализующий <code class="notranslate">Handler</code> может служить для HTTP запросов.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">Handler</span> <span class="pl-k">interface</span> {
    <span class="pl-c1">ServeHTTP</span>(<span class="pl-smi">ResponseWriter</span>, <span class="pl-c1">*</span><span class="pl-smi">Request</span>)
}</pre></div>
<p>Сам интерфейс <code class="notranslate">ResponseWriter</code> обеспечивает функции для возврата ответа клиенту.<br/>
Эти функции включают метод <code class="notranslate">Write</code>, то <code class="notranslate">http.ResponseWriter</code> можно  использовать везде как где можно использовать <code class="notranslate">io.Writer</code>. <code class="notranslate">Request(Запрос)</code> это структура хранящая информацию о запросе от клиента.</p>
<p>Для упрощения, давайте игнорировать POSTs и предположим что HTTP запросы всегда используют GETs; Это упрощение не влияет на способ настройки обработчика <em>handlers</em>.<br/>
К примеру следующий код показывает полный обработчик для подсчета количества раз показа данной страницы.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// Simple counter server.</span>
<span class="pl-k">type</span> <span class="pl-smi">Counter</span> <span class="pl-k">struct</span> {
    <span class="pl-c1">n</span> <span class="pl-smi">int</span>
}

<span class="pl-k">func</span> (<span class="pl-s1">ctr</span> <span class="pl-c1">*</span><span class="pl-smi">Counter</span>) <span class="pl-en">ServeHTTP</span>(<span class="pl-s1">w</span> http.<span class="pl-smi">ResponseWriter</span>, <span class="pl-s1">req</span> <span class="pl-c1">*</span>http.<span class="pl-smi">Request</span>) {
    <span class="pl-s1">ctr</span>.<span class="pl-c1">n</span><span class="pl-c1">++</span>
    <span class="pl-s1">fmt</span>.<span class="pl-en">Fprintf</span>(<span class="pl-s1">w</span>, <span class="pl-s">&#34;counter = %d<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">ctr</span>.<span class="pl-c1">n</span>)
}</pre></div>
<p>(Обратите внимание, на то как <code class="notranslate">Fprintf</code> печатает в <code class="notranslate">http.ResponseWriter</code>.)<br/>
Для справки, следующий код показывает как присоединить сервер к узлу в <em>URL tree</em>.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-s">&#34;net/http&#34;</span>
<span class="pl-c1">...</span>
<span class="pl-s1">ctr</span> <span class="pl-c1">:=</span> <span class="pl-en">new</span>(<span class="pl-smi">Counter</span>)
<span class="pl-s1">http</span>.<span class="pl-en">Handle</span>(<span class="pl-s">&#34;/counter&#34;</span>, <span class="pl-s1">ctr</span>)</pre></div>
<p>Но зачем использовать структуру для <code class="notranslate">Counter</code>? Все что нам необходимо - это целое число.<br/>
(Для получателя <em>receiver</em> необходим указатель, тогда инкремент будет виден для вызывающего)</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// Simpler counter server.</span>
<span class="pl-k">type</span> <span class="pl-smi">Counter</span> <span class="pl-smi">int</span>

<span class="pl-k">func</span> (<span class="pl-s1">ctr</span> <span class="pl-c1">*</span><span class="pl-smi">Counter</span>) <span class="pl-en">ServeHTTP</span>(<span class="pl-s1">w</span> http.<span class="pl-smi">ResponseWriter</span>, <span class="pl-s1">req</span> <span class="pl-c1">*</span>http.<span class="pl-smi">Request</span>) {
    <span class="pl-c1">*</span><span class="pl-s1">ctr</span><span class="pl-c1">++</span>
    <span class="pl-s1">fmt</span>.<span class="pl-en">Fprintf</span>(<span class="pl-s1">w</span>, <span class="pl-s">&#34;counter = %d<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-c1">*</span><span class="pl-s1">ctr</span>)
}</pre></div>
<p>Что делать если Ваша программа имеет некое внутреннее состояние и необходимо уведомить что страница была посещена? Необходимо связать веб страницы каналом.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// A channel that sends a notification on each visit.</span>
<span class="pl-c">// (Probably want the channel to be buffered.)</span>
<span class="pl-k">type</span> <span class="pl-smi">Chan</span> <span class="pl-k">chan</span> <span class="pl-c1">*</span>http.<span class="pl-smi">Request</span>

<span class="pl-k">func</span> (<span class="pl-s1">ch</span> <span class="pl-smi">Chan</span>) <span class="pl-en">ServeHTTP</span>(<span class="pl-s1">w</span> http.<span class="pl-smi">ResponseWriter</span>, <span class="pl-s1">req</span> <span class="pl-c1">*</span>http.<span class="pl-smi">Request</span>) {
    <span class="pl-s1">ch</span> <span class="pl-c1">&lt;-</span> <span class="pl-s1">req</span>
    <span class="pl-s1">fmt</span>.<span class="pl-en">Fprint</span>(<span class="pl-s1">w</span>, <span class="pl-s">&#34;notification sent&#34;</span>)
}</pre></div>
<p>Если нам требуется представить на <code class="notranslate">/args</code> аргументы использованные для запуска приложения сервера.<br/>
Просто необходимо написать функцию для печати аргументов.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">ArgServer</span>() {
    <span class="pl-s1">fmt</span>.<span class="pl-en">Println</span>(<span class="pl-s1">os</span>.<span class="pl-c1">Args</span>)
}</pre></div>
<p>Как превратить это в HTTP сервер?  Мы могли бы сделать метод <code class="notranslate">ArgServer</code> некоторого типа значение которого мы игнорируем, но есть более простой путь.<br/>
Так как мы можем определить метод для любого типа, кроме указателя и интерфейса, то мы можем записать метод для функции.<br/>
В пакете <code class="notranslate">http</code> есть следующий код:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// The HandlerFunc type is an adapter to allow the use of</span>
<span class="pl-c">// ordinary functions as HTTP handlers.  If f is a function</span>
<span class="pl-c">// with the appropriate signature, HandlerFunc(f) is a</span>
<span class="pl-c">// Handler object that calls f.</span>
<span class="pl-k">type</span> <span class="pl-smi">HandlerFunc</span> <span class="pl-k">func</span>(<span class="pl-smi">ResponseWriter</span>, <span class="pl-c1">*</span><span class="pl-smi">Request</span>)

<span class="pl-c">// ServeHTTP calls f(c, req).</span>
<span class="pl-k">func</span> (<span class="pl-s1">f</span> <span class="pl-smi">HandlerFunc</span>) <span class="pl-en">ServeHTTP</span>(<span class="pl-s1">w</span> <span class="pl-smi">ResponseWriter</span>, <span class="pl-s1">req</span> <span class="pl-c1">*</span><span class="pl-smi">Request</span>) {
    <span class="pl-en">f</span>(<span class="pl-s1">w</span>, <span class="pl-s1">req</span>)
}</pre></div>
<p>Это тип <code class="notranslate">HandlerFunc</code> с методом <code class="notranslate">ServeHTTP</code>, поэтому значения данного типа может служит для запросов HTTP. Посмотрим на реализацию метода: <em>receiver</em> это функция, <code class="notranslate">f</code>, и метод называется <code class="notranslate">f</code>. Это может показаться странным, но это ничем не отличается от работы с каналами и метод бы отсылал на канал.</p>
<p>Для создания <code class="notranslate">ArgServer</code> как HTTP сервера, вначале мы изменим корректную сигнатуру.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// Argument server.</span>
<span class="pl-k">func</span> <span class="pl-en">ArgServer</span>(<span class="pl-s1">w</span> http.<span class="pl-smi">ResponseWriter</span>, <span class="pl-s1">req</span> <span class="pl-c1">*</span>http.<span class="pl-smi">Request</span>) {
    <span class="pl-s1">fmt</span>.<span class="pl-en">Fprintln</span>(<span class="pl-s1">w</span>, <span class="pl-s1">os</span>.<span class="pl-c1">Args</span>)
}</pre></div>
<p>Сейчас, <code class="notranslate">ArgServer</code> имеет ту же сигнатуру как <code class="notranslate">HandlerFunc</code>, поэтому его можно конвертировать в этот тип для доступа к его методам, просто как сконвертировать <code class="notranslate">Sequence</code> в <code class="notranslate">IntSlice</code> для доступа к <code class="notranslate">IntSlice.Sort</code>.<br/>
Код для настройки лаконичен:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">http</span>.<span class="pl-en">Handle</span>(<span class="pl-s">&#34;/args&#34;</span>, <span class="pl-s1">http</span>.<span class="pl-en">HandlerFunc</span>(<span class="pl-s1">ArgServer</span>))</pre></div>
<p>Когда кто-то посещает страницу <code class="notranslate">/args</code>, обработчик <strong>handler</strong> устанавливает страницу со значением <code class="notranslate">ArgServer</code> и типом <code class="notranslate">HandlerFunc</code>.<br/>
Сервер HTTP будет вызывать метод <code class="notranslate">ServeHTTP</code> данного типа с получателем <code class="notranslate">ArgServer</code>, который будет вызывать <code class="notranslate">ArgServer</code> через вызов <code class="notranslate">f(c, req)</code> внутри <code class="notranslate">HandlerFunc.ServeHTTP</code>.<br/>
Вследствие этого аргументы будут отображены.</p>
<p>В этом разделе мы сделали сервер HTTP из структуры, целого числа, канала, и функции, все потому что интерфейсы имеют только набор методов, которые могут быть определены для (почти) любого типа.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h2 id="pexmzEqQWQzZoTfz">Пустой идентификатор (The blank identifier <strong>_</strong>)</h2>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Мы уже упоминали пустой идентификатор пару раз, в разделах о циклах <code class="notranslate">for</code> <code class="notranslate">range</code> и картах <code class="notranslate">maps</code>.<br/>
Пустой идентификатор может быть назначен или объявлен для любого типа, значение при этом отбрасывается.<br/>
Это чем то похоже на запись в Unix файл в <code class="notranslate">/dev/null</code>: Это значение только на запись, где переменная необходима, но значение не важно.<br/>
Есть дополнительные способы использования.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="XWcYVsGQeWGiQmQE">Пустой идентификатор в множественном присваивании (<strong>_</strong>)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Использование пустого идентификатора в цикле <code class="notranslate">for</code> <code class="notranslate">range</code> является лишь одним случаем применения в общей картине множественного присваивания.</p>
<p>Если требуется множество значений на левой стороне при присваивании, но одно из значений не будет использоваться программой, то используется пустой идентификатор на левой стороне присвоения для того чтобы избежать необходимости в ненужных переменных и создании понимания что значение отброшенное.<br/>
Например, когда вызывается функция возвращающая значение и ошибку, но при этом только ошибка важна, то пустой идентификатор используется для того чтобы отбросить ненужное значение.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">if</span> <span class="pl-s1">_</span>, <span class="pl-s1">err</span> <span class="pl-c1">:=</span> <span class="pl-s1">os</span>.<span class="pl-en">Stat</span>(<span class="pl-s1">path</span>); <span class="pl-s1">os</span>.<span class="pl-en">IsNotExist</span>(<span class="pl-s1">err</span>) {
	<span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;%s does not exist<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">path</span>)
}</pre></div>
<p>Иногда Вы увидите код в котором отбрасывается ошибка, это ужасная практика. Всегда проверяйте возвращенную ошибку, так как они предоставляются по некой причине.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// Bad! This code will crash if path does not exist.</span>
<span class="pl-s1">fi</span>, <span class="pl-s1">_</span> <span class="pl-c1">:=</span> <span class="pl-s1">os</span>.<span class="pl-en">Stat</span>(<span class="pl-s1">path</span>)
<span class="pl-k">if</span> <span class="pl-s1">fi</span>.<span class="pl-en">IsDir</span>() {
    <span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;%s is a directory<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">path</span>)
}</pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="tsSblJgMIqXEGtPH">Неиспользуемое импортирование и значения</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Ошибкой является неиспользование пакета или объявление переменной без использования.<br/>
Неиспользованный импорт увеличивает программу и делает компиляцию медленнее, в то время как переменная инициализированная но не используется, по крайней мере приводит к пустому вычислению или может является индикатором об ошибке.<br/>
Однако неиспользуемые импорты и переменные возникают, когда программа на стадии активной разработки и удаление их может раздражать, только лишь для того чтобы прошла компиляция и если они снова понадобятся позже.<br/>
Пустые идентификаторы позволяют создать обход(<strong>workaround</strong>).</p>
<p>Это полунаписанная программа имеет два неиспользуемых импорта (<code class="notranslate">fmt</code> и <code class="notranslate">io</code>) и не используемую переменную (<code class="notranslate">fd</code>), и она не проходит компиляцию, но было бы хорошо если бы можно было увидеть, что код корректен.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">///{{code &#34;/doc/progs/eff_unused1.go&#34; `/package/` `$`}}</span>
<span class="pl-k">package</span> main

<span class="pl-k">import</span> (
	<span class="pl-s">&#34;fmt&#34;</span>
	<span class="pl-s">&#34;io&#34;</span>
	<span class="pl-s">&#34;log&#34;</span>
	<span class="pl-s">&#34;os&#34;</span>
)

<span class="pl-k">func</span> <span class="pl-en">main</span>() {
	<span class="pl-s1">fd</span>, <span class="pl-s1">err</span> <span class="pl-c1">:=</span> <span class="pl-s1">os</span>.<span class="pl-en">Open</span>(<span class="pl-s">&#34;test.go&#34;</span>)
	<span class="pl-k">if</span> <span class="pl-s1">err</span> <span class="pl-c1">!=</span> <span class="pl-c1">nil</span> {
		<span class="pl-s1">log</span>.<span class="pl-en">Fatal</span>(<span class="pl-s1">err</span>)
	}
	<span class="pl-c">// TODO: use fd.</span>
}</pre></div>
<p>Для того чтобы избежать жалоб о неиспользуемых импортах, необходимо использовать символ пустого идентификатора для обозначения импортирования пакета.<br/>
Аналогично, можно поступать с неиспользуемой переменной <code class="notranslate">fd</code> при использовании пустого идентификатора, что приведёт к избеганию ошибки о неиспользованной переменной.<br/>
Следующая версия программы будет компилироваться.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">//{{code &#34;/doc/progs/eff_unused2.go&#34; `/package/` `$`}}</span>
<span class="pl-k">package</span> main

<span class="pl-k">import</span> (
	<span class="pl-s">&#34;fmt&#34;</span>
	<span class="pl-s">&#34;io&#34;</span>
	<span class="pl-s">&#34;log&#34;</span>
	<span class="pl-s">&#34;os&#34;</span>
)

<span class="pl-k">var</span> <span class="pl-s1">_</span> <span class="pl-c1">=</span> <span class="pl-s1">fmt</span>.<span class="pl-c1">Printf</span> <span class="pl-c">// For debugging; delete when done.</span>
<span class="pl-k">var</span> <span class="pl-s1">_</span> io.<span class="pl-smi">Reader</span>    <span class="pl-c">// For debugging; delete when done.</span>

<span class="pl-k">func</span> <span class="pl-en">main</span>() {
	<span class="pl-s1">fd</span>, <span class="pl-s1">err</span> <span class="pl-c1">:=</span> <span class="pl-s1">os</span>.<span class="pl-en">Open</span>(<span class="pl-s">&#34;test.go&#34;</span>)
	<span class="pl-k">if</span> <span class="pl-s1">err</span> <span class="pl-c1">!=</span> <span class="pl-c1">nil</span> {
		<span class="pl-s1">log</span>.<span class="pl-en">Fatal</span>(<span class="pl-s1">err</span>)
	}
	<span class="pl-c">// TODO: use fd.</span>
	<span class="pl-s1">_</span> <span class="pl-c1">=</span> <span class="pl-s1">fd</span>
}</pre></div>
<p>В соответствии с соглашением, глобальное объявление для замалчивания ошибки импорта должно идти сразу за импортированием и должно быть откомментировано, это сделано для того чтобы легко можно было найти и помнить об отчистки позже.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="JIMLptPmQnacCavc">Импортирование для побочного эффекта (Import for side effect)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Неиспользуемые импорты, как например <code class="notranslate">fmt</code> и <code class="notranslate">io</code> в предыдущем примере, в конечном счете должны быть удалены: пустое задание должно определять что код в процессе разработки.<br/>
Но иногда, используется импортирование пакета только для создания побочного влияния, без какого либо явного использования.<br/>
К примеру, для функции <code class="notranslate">init</code> в пакете <a href="https://golang.org/pkg/net/http/pprof/" rel="nofollow">net/http/pprof</a> регистрирует HTTP обработчики для обеспечения отладочной информацией.<br/>
Он имеет экспортированный API, но большинству клиентов необходима только регистрация обработчиков и получение доступа к данным через веб-страницу.<br/>
Только для импортирования пакета с этим побочным эффектом, переименовывают пакет в пустой идентификатор:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">import</span> _ <span class="pl-s">&#34;net/http/pprof&#34;</span></pre></div>
<p>Эта форма импортирования означает, что данный пакет импортируется для данного побочного эффекта, потому что нет другой возможности использовать пакет: в этот файл, не имеет имени. (Если же он имеет и мы не используем это имя, то компилятор отменит программу.)</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="JfoeYvdhbieoxXXM">Проверка интерфейса (Interface checks)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Как мы видели ранее в разделе об интерфейсах, нет необходимости в объявлении что тип реализует определенный интерфейс.<br/>
Вместо этого, тип реализует интерфейс только путем реализации методов интерфейса.<br/>
На практике, большинство преобразований интерфейсов статично и поэтому проверяется во время компиляции.</p>
<p>К примеру, передавая <code class="notranslate">*os.File</code> в функцию ожидающая <code class="notranslate">io.Reader</code> не будет скомпилировано, так как <code class="notranslate">*os.File</code> не реализует интерфейс <code class="notranslate">io.Reader</code>.</p>
<p>Хотя все же некоторые проверки интерфейсов происходят во время выполнения.<br/>
Один из примеров в пакете <a href="https://golang.org/pkg/encoding/json/" rel="nofollow">encoding/json</a>, который определяет интерфейс <a href="https://golang.org/pkg/encoding/json/#Marshaler" rel="nofollow">Marshaler</a>. Когда <strong>JSON encoder</strong> принимает значение, которое реализует этот интерфейс, <em>encoder</em> вызывает функцию упаковщик значений для преобразования в JSON, в отличии от стандартного преобразования.</p>
<p><em>Encoder</em> проверяет эти свойства во время работы:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">m</span>, <span class="pl-s1">ok</span> <span class="pl-c1">:=</span> <span class="pl-s1">val</span>.(json.<span class="pl-smi">Marshaler</span>)</pre></div>
<p>Если необходимо только запросить тип реализуемого интерфейса без использования самого интерфейса, то это часть проверки ошибок, используйте пустой идентификатор для игнорирования защиты типов:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">if</span> <span class="pl-s1">_</span>, <span class="pl-s1">ok</span> <span class="pl-c1">:=</span> <span class="pl-s1">val</span>.(json.<span class="pl-smi">Marshaler</span>); <span class="pl-s1">ok</span> {
    <span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;value %v of type %T implements json.Marshaler<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-s1">val</span>, <span class="pl-s1">val</span>)
}</pre></div>
<p>Одна из ситуаций применения это когда необходимо гарантировать в рамках пакета что данный тип реализует интерфейс.<br/>
Если взглянуть на пример <a href="https://golang.org/pkg/encoding/json/#RawMessage" rel="nofollow">json.RawMessage</a>, где необходима пользовательское представление в формате JSON, он должен реализовывать <code class="notranslate">json.Marshaler</code>, но отсутствует статическое преобразование для автоматической проверки компилятором.<br/>
Если определенный тип не будет реализовывать интерфейс, то <em>JSON encoder</em> будет все же работать, но без пользовательской реализации.<br/>
Для гарантирования корректной реализации, в пакете можете использовать пустой идентификатор для глобальной декларации:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">var</span> <span class="pl-s1">_</span> json.<span class="pl-smi">Marshaler</span> <span class="pl-c1">=</span> (<span class="pl-c1">*</span><span class="pl-s1">RawMessage</span>)(<span class="pl-c1">nil</span>)</pre></div>
<p>в этой деклорации, присвоение с конвертацией <code class="notranslate">*RawMessage</code> к <code class="notranslate">Marshaler</code> требует чтобы, <code class="notranslate">*RawMessage</code> реализовывал <code class="notranslate">Marshaler</code> и данная проверка будет производиться во время компиляции.<br/>
В случаи если интерфейс <code class="notranslate">json.Marshaler</code>, этот пакет не будет компилироваться и мы будем знать об обновлении.</p>
<p>Использование пустого идентификатора в данном случае является индикатором о проверки типов, и при этом не создается переменной.<br/>
Не используйте этот подход для проверки каждого типа.<br/>
В соответствии с соглашением, такое объявление используется только когда отсутствует статическая конвертация уже существующая в коде, и является редким событием.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h2 id="pnjCbYrZjJxCWpLd">Вложение (Embedding)</h2>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Язык Go не поддерживает типичное управление типов подклассов, но он имеет возможность &#34;заимствовать&#34; части реализации с помощью типа <em>вложения</em> структуры или интерфейса.</p>
<p>Вложение интерфейса необычно простое.<br/>
Мы уже упоминали об интерфейсах <code class="notranslate">io.Reader</code> and <code class="notranslate">io.Writer</code> ранее, вот их определение.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">Reader</span> <span class="pl-k">interface</span> {
    <span class="pl-c1">Read</span>(<span class="pl-s1">p</span> []<span class="pl-smi">byte</span>) (<span class="pl-s1">n</span> <span class="pl-smi">int</span>, <span class="pl-s1">err</span> <span class="pl-smi">error</span>)
}

<span class="pl-k">type</span> <span class="pl-smi">Writer</span> <span class="pl-k">interface</span> {
    <span class="pl-c1">Write</span>(<span class="pl-s1">p</span> []<span class="pl-smi">byte</span>) (<span class="pl-s1">n</span> <span class="pl-smi">int</span>, <span class="pl-s1">err</span> <span class="pl-smi">error</span>)
}</pre></div>
<p>Пакет <code class="notranslate">io</code> также экспортирует несколько других интерфейсов, которые определяют объекты, которые могут реализовывать несколько таких методов.<br/>
К примеру, <code class="notranslate">io.ReadWriter</code> содержит оба интерфейса <code class="notranslate">Read</code> и <code class="notranslate">Write</code>.<br/>
Мы может указать <code class="notranslate">io.ReadWriter</code> перечислением двух методов в явном виде, но проще и более запомяющим будет встраивание двух интерфейсов в одну новую форму, вот так:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// ReadWriter is the interface that combines the Reader and Writer interfaces.</span>
<span class="pl-k">type</span> <span class="pl-smi">ReadWriter</span> <span class="pl-k">interface</span> {
    <span class="pl-smi">Reader</span>
    <span class="pl-smi">Writer</span>
}</pre></div>
<p>Это выглядит следующим образом: <code class="notranslate">ReadWriter</code> может делать все что делает <code class="notranslate">Reader</code> <strong>и</strong> что делает <code class="notranslate">Writer</code>. Это объединение встраивания интерфейсов (которые не имеют пересечений в методах).<br/>
Только интерфейсы могут встраивать интерфейсы.</p>
<p>Аналогичная идея используется для структур, но с большим количеством последствий. Пакет <code class="notranslate">bufio</code> имеет две структуры типов - <code class="notranslate">bufio.Reader</code> и <code class="notranslate">bufio.Writer</code>, каждая из которых реализует аналогичные интерфейсы как в пакете <code class="notranslate">io</code>. И <code class="notranslate">bufio</code> также реализует буферизованное чтение/запись, которое объединяет чтение и запись в одну структуру с использованием вложения: этот список типов структур, но не давая имена полям.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// ReadWriter stores pointers to a Reader and a Writer.</span>
<span class="pl-c">// It implements io.ReadWriter.</span>
<span class="pl-k">type</span> <span class="pl-smi">ReadWriter</span> <span class="pl-k">struct</span> {
    <span class="pl-c1">*</span><span class="pl-smi">Reader</span>  <span class="pl-c">// *bufio.Reader</span>
    <span class="pl-c1">*</span><span class="pl-smi">Writer</span>  <span class="pl-c">// *bufio.Writer</span>
}</pre></div>
<p>Вложение указателей элементов в структуры и конечно должно быть инициализировано необходимой структурой до его использования.<br/>
Структура <code class="notranslate">ReadWriter</code> может быть записана так:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">ReadWriter</span> <span class="pl-k">struct</span> {
    <span class="pl-c1">reader</span> <span class="pl-c1">*</span><span class="pl-smi">Reader</span>
    <span class="pl-c1">writer</span> <span class="pl-c1">*</span><span class="pl-smi">Writer</span>
}</pre></div>
<p><strong>TODO</strong><br/>
but then to promote the methods of the fields and to<br/>
satisfy the <code class="notranslate">io</code> interfaces, we would also need<br/>
to provide forwarding methods, like this:<br/>
<strong>-</strong></p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> (<span class="pl-s1">rw</span> <span class="pl-c1">*</span><span class="pl-smi">ReadWriter</span>) <span class="pl-en">Read</span>(<span class="pl-s1">p</span> []<span class="pl-smi">byte</span>) (<span class="pl-s1">n</span> <span class="pl-smi">int</span>, <span class="pl-s1">err</span> <span class="pl-smi">error</span>) {
    <span class="pl-k">return</span> <span class="pl-s1">rw</span>.<span class="pl-c1">reader</span>.<span class="pl-en">Read</span>(<span class="pl-s1">p</span>)
}</pre></div>
<p>Для непосредственного вложения структур, мы должны избегать эту бухгалтерию.<br/>
Метод вложенного типа приходит свободно, что означает что <code class="notranslate">bufio.ReadWriter</code> имеет не только его методы <code class="notranslate">bufio.Reader</code> и <code class="notranslate">bufio.Writer</code>, а также удовлетворяет всем трем интерфейсам:</p>
<ul>
<li><code class="notranslate">io.Reader</code>,</li>
<li><code class="notranslate">io.Writer</code>, и</li>
<li><code class="notranslate">io.ReadWriter</code>.</li>
</ul>
<p>Это важное отличие вложения от подклассов. Когда мы вкладываем тип, методы этого типа становятся методами внешнего типа, но для получателя они вызываются как встроенные типы, а не внешние.<br/>
В нашем примере, когда метод <code class="notranslate">Read</code> из <code class="notranslate">bufio.ReadWriter</code> вызывается, он и вызываются также как описано выше; получатель поля <code class="notranslate">reader</code> из <code class="notranslate">ReadWriter</code>, является самим <code class="notranslate">ReadWriter</code>.</p>
<p>Вложение может быть простым и удобным.<br/>
Этот пример показывает вложение поля рядом с именованным полем.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">Job</span> <span class="pl-k">struct</span> {
    <span class="pl-c1">Command</span> <span class="pl-smi">string</span>
    <span class="pl-c1">*</span>log.<span class="pl-smi">Logger</span>
}</pre></div>
<p>Тип <code class="notranslate">Job</code> сейчас имеет <code class="notranslate">Log</code>, <code class="notranslate">Logf</code> и другие методы <code class="notranslate">*log.Logger</code>.<br/>
Мы могли бы дать имя для <code class="notranslate">Logger</code>, конечно же, но в этом нет необходимости. И сейчас, мы можем логировать <code class="notranslate">Job</code>:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">job</span>.<span class="pl-en">Log</span>(<span class="pl-s">&#34;starting now...&#34;</span>)</pre></div>
<p>Регулярное поле <code class="notranslate">Logger</code> в структуре <code class="notranslate">Job</code>, поэтому мы можем инициализировать его как обычно внутри конструктора <code class="notranslate">Job</code>, вот так:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">NewJob</span>(<span class="pl-s1">command</span> <span class="pl-smi">string</span>, <span class="pl-s1">logger</span> <span class="pl-c1">*</span>log.<span class="pl-smi">Logger</span>) <span class="pl-c1">*</span><span class="pl-smi">Job</span> {
    <span class="pl-k">return</span> <span class="pl-c1">&amp;</span><span class="pl-smi">Job</span>{<span class="pl-s1">command</span>, <span class="pl-s1">logger</span>}
}</pre></div>
<p>или с помощью составных литералов:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">job</span> <span class="pl-c1">:=</span> <span class="pl-c1">&amp;</span><span class="pl-smi">Job</span>{<span class="pl-s1">command</span>, <span class="pl-s1">log</span>.<span class="pl-en">New</span>(<span class="pl-s1">os</span>.<span class="pl-c1">Stderr</span>, <span class="pl-s">&#34;Job: &#34;</span>, <span class="pl-s1">log</span>.<span class="pl-c1">Ldate</span>)}</pre></div>
<p>Если нам необходимо обратиться непосредственно к вложенному полю, имени типа поля, игнорируя пакетный классификатор, как к имени поля, как это сделано в методе <code class="notranslate">Read</code> в нашей структуре <code class="notranslate">ReaderWriter</code>.<br/>
При этом нам необходим доступ к <code class="notranslate"> * log.Logger</code> в <code class="notranslate">Job</code> переменной <code class="notranslate">job</code>, мы можем написать <code class="notranslate">job.Logger</code>, что полезно если мы хотим уточнить методы <code class="notranslate">Logger</code>.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> (<span class="pl-s1">job</span> <span class="pl-c1">*</span><span class="pl-smi">Job</span>) <span class="pl-en">Logf</span>(<span class="pl-s1">format</span> <span class="pl-smi">string</span>, <span class="pl-s1">args</span> <span class="pl-c1">...</span><span class="pl-k">interface</span>{}) {
    <span class="pl-s1">job</span>.<span class="pl-c1">Logger</span>.<span class="pl-en">Logf</span>(<span class="pl-s">&#34;%q: %s&#34;</span>, <span class="pl-s1">job</span>.<span class="pl-c1">Command</span>, <span class="pl-s1">fmt</span>.<span class="pl-en">Sprintf</span>(<span class="pl-s1">format</span>, <span class="pl-s1">args</span><span class="pl-c1">...</span>))
}</pre></div>
<p>Вложение типов создает проблему конфликта имен, но правила для их решения просты.</p>
<p>Первое, поля или метод <code class="notranslate">X</code> скрывает любой иной элемент <code class="notranslate">X</code> в более глубокой части вложенного типа.<br/>
Если <code class="notranslate">log.Logger</code> содержит поле или метод под названием <code class="notranslate">Command</code>, то поле <code class="notranslate">Command</code> в <code class="notranslate">Job</code> будет преобладать над ним.</p>
<p>Во-вторых, если есть одинаковые имена на том же уровне вложенности, это как правило ошибка и было бы ошибочно вставлять <code class="notranslate">log.Logger</code>, если структура <code class="notranslate">Job</code> имеет другое вложенное поле или метод с названием <code class="notranslate">Logger</code>.<br/>
Однако, если дублированные имена никогда не встречается в программе вне определённого типа, то это нормально.<br/>
Это защищает от изменения типов вложенности за его пределами; и это не проблема, если добавлено поле вступающее в конфликт с другим полем в другом подтипе, если ни одно из полей не используется.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h2 id="TdJzSwVZIdAAROvu">Согласованность, параллельная обработка, параллельное выполнение  (Concurrency)</h2>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="DzEzXerMGDuYBwbJ">Распределение памяти по сообщениям (Share by communicating)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Параллельное программирование является большой темой и здесь будет рассматриваться только специфичное для языка Go.</p>
<p>Параллельное программирование во многих средах затруднено для корректной реализации доступа к общим переменным.</p>
<p>В языке Go поддерживается другой подход, в котором общие переменные <em>shared values</em> передаются через каналы, по сути, никогда активно не распределяется по исполняемым потокам.<br/>
Только одна го-рутина(<strong>goroutine</strong>) имеет доступ к переменной в любой момент.<br/>
Перенос данных не происходит по конструкции языка.<br/>
Для того чтобы способствовать данному стилю мышления используется лозунг:</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<blockquote>
<p>Не общайтесь с распределением памяти; Вместо того чтобы распределять память по коммуникациям.</p>
</blockquote>
<p>Это дальновидный подход. К примеру, наилучшим образом подсчет ссылок можно производить установкой мютексов(<strong>mutex</strong>) вокруг целого переменной.<br/>
Но это высокоуровневый подход, использование каналов для контроля доступа является более простым и корректным для программ.</p>
<p>Один из способов думать об этой модели как для типичных однопоточных программ запущенных на одном процессоре CPU. И нет необходимости в синхронизации примитивов.<br/>
Для запуска следующего экземпляра, нет необходимости в синхронизации. Сейчас рассмотрим два способа коммуникации; Если коммуникация синхронна, то все также не требуется дополнительной синхронизации. К примеру, <em>Unix pipelines</em> великолепно используют эту модель. Хотя подход языка Go для организации параллельных процессов берет начало в <strong>Hoare&#39;s Communicating Sequential Processes (CSP)</strong>, он также может рассматриваться как обобщение безопасности типов Unix pipes.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="YQtRgjAiqfpVcmlU">Го-рутины (Goroutines)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Они называются Го-рутины, потому что существующие термины потоки, корутины, процессы и так далее передают неточную коннотацию.<br/>
<strong>Го-рутины</strong> имеют простую модель: это функция выполняющаяся параллельно с другими го-рутинами в одном адресном пространстве. Они легковесны стоящие чуть больше чем выделение пространства в стэке. Они дешевы, и растут по мере необходимости путем выделения или освобождения в куче.</p>
<p>Горутины распределяются на несколько потоков OS, и если один заблокируются, например из-за ожидания I/O, другие продолжат работу. Их дизайн скрывает много сложностей по создание потоков и их управлению.</p>
<p>Префикс <code class="notranslate">go</code> у функции или метода запускает новую горутину.<br/>
Когда вызов закончен, горутина выходит, молча. (Этот эффект похож на команду Unix с нотацией <code class="notranslate">&amp;</code> означающая запуск команды в фоновом режиме.)</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">go</span> <span class="pl-s1">list</span>.<span class="pl-en">Sort</span>()  <span class="pl-c">// run list.Sort concurrently; don&#39;t wait for it.</span></pre></div>
<p>Встроенные функции могут быть удобны для вызова горутин.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">Announce</span>(<span class="pl-s1">message</span> <span class="pl-smi">string</span>, <span class="pl-s1">delay</span> time.<span class="pl-smi">Duration</span>) {
    <span class="pl-k">go</span> <span class="pl-k">func</span>() {
        <span class="pl-s1">time</span>.<span class="pl-en">Sleep</span>(<span class="pl-s1">delay</span>)
        <span class="pl-s1">fmt</span>.<span class="pl-en">Println</span>(<span class="pl-s1">message</span>)
    }()  <span class="pl-c">// Note the parentheses - must call the function.</span>
}</pre></div>
<p>В языке Go, встроенные функции закрываемые и их реализация гарантирует что ссылаемые переменные будут жить до тех пор пока функция активна.</p>
<p>Эти примеры не очень практичны, так как функции не имеют сигнализировать о своем завершении. Для этого у нас есть каналы.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="OcdAMSYwbcqScwGd">Каналы (Channels)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Каналы, как и карты(map) выделяются в памяти с помощью <code class="notranslate">make</code> и полученное значение является ссылкой на изначальную структуру данных.<br/>
Если задан необязательный целый параметр, то он указывает на размер буфера в канале.<br/>
По умолчанию, значение нулевое, как для небуферезованного или синхронного канала.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">ci</span> <span class="pl-c1">:=</span> <span class="pl-en">make</span>(<span class="pl-k">chan</span> <span class="pl-smi">int</span>)            <span class="pl-c">// unbuffered channel of integers</span>
<span class="pl-s1">cj</span> <span class="pl-c1">:=</span> <span class="pl-en">make</span>(<span class="pl-k">chan</span> <span class="pl-smi">int</span>, <span class="pl-c1">0</span>)         <span class="pl-c">// unbuffered channel of integers</span>
<span class="pl-s1">cs</span> <span class="pl-c1">:=</span> <span class="pl-en">make</span>(<span class="pl-k">chan</span> <span class="pl-c1">*</span>os.<span class="pl-smi">File</span>, <span class="pl-c1">100</span>)  <span class="pl-c">// buffered channel of pointers to Files</span></pre></div>
<p>Небуферезованные каналы гарантируют, что обмен значениями будет синхронным между двумя горутинами в известном состоянии.</p>
<p>Есть много хороших идиом использования каналов. Вот один с которого мы начнем.<br/>
В предыдущем разделе мы запускали сортировку в фоне. Канал может помочь отследить завершение горутины с сортировкой.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">c</span> <span class="pl-c1">:=</span> <span class="pl-en">make</span>(<span class="pl-k">chan</span> <span class="pl-smi">int</span>)  <span class="pl-c">// Allocate a channel.</span>
<span class="pl-c">// Start the sort in a goroutine; when it completes, signal on the channel.</span>
<span class="pl-k">go</span> <span class="pl-k">func</span>() {
    <span class="pl-s1">list</span>.<span class="pl-en">Sort</span>()
    <span class="pl-s1">c</span> <span class="pl-c1">&lt;-</span> <span class="pl-c1">1</span>  <span class="pl-c">// Send a signal; value does not matter.</span>
}()
<span class="pl-en">doSomethingForAWhile</span>()
<span class="pl-c1">&lt;-</span><span class="pl-s1">c</span>   <span class="pl-c">// Wait for sort to finish; discard sent value.</span></pre></div>
<p>Получатель всегда блокируется до тех пор пока данные не получит получатель.<br/>
Если канал не буферизованный, отсылающий блокируется до тех пор пока получатель не получит данные.<br/>
Если канал буферизованный, то отсылающий блокируется только тогда когда значение копируется в буфер; если буфер полон, то будет ожидать до тех пор пока получатель не получит значение.</p>
<p><strong>TODO</strong><br/>
A buffered channel can be used like a semaphore, for instance to<br/>
limit throughput.  In this example, incoming requests are passed<br/>
to <code class="notranslate">handle</code>, which sends a value into the channel, processes<br/>
the request, and then receives a value from the channel<br/>
to ready the &#34;semaphore&#34; for the next consumer.<br/>
The capacity of the channel buffer limits the number of<br/>
simultaneous calls to <code class="notranslate">process</code>.<br/>
<strong>-</strong></p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">var</span> <span class="pl-s1">sem</span> <span class="pl-c1">=</span> <span class="pl-en">make</span>(<span class="pl-k">chan</span> <span class="pl-smi">int</span>, <span class="pl-s1">MaxOutstanding</span>)

<span class="pl-k">func</span> <span class="pl-en">handle</span>(<span class="pl-s1">r</span> <span class="pl-c1">*</span><span class="pl-smi">Request</span>) {
    <span class="pl-s1">sem</span> <span class="pl-c1">&lt;-</span> <span class="pl-c1">1</span>    <span class="pl-c">// Wait for active queue to drain.</span>
    <span class="pl-en">process</span>(<span class="pl-s1">r</span>)  <span class="pl-c">// May take a long time.</span>
    <span class="pl-c1">&lt;-</span><span class="pl-s1">sem</span>       <span class="pl-c">// Done; enable next request to run.</span>
}

<span class="pl-k">func</span> <span class="pl-en">Serve</span>(<span class="pl-s1">queue</span> <span class="pl-k">chan</span> <span class="pl-c1">*</span><span class="pl-smi">Request</span>) {
    <span class="pl-k">for</span> {
        <span class="pl-s1">req</span> <span class="pl-c1">:=</span> <span class="pl-c1">&lt;-</span><span class="pl-s1">queue</span>
        <span class="pl-k">go</span> <span class="pl-en">handle</span>(<span class="pl-s1">req</span>)  <span class="pl-c">// Don&#39;t wait for handle to finish.</span>
    }
}</pre></div>
<p><strong>TODO</strong><br/>
Once <code class="notranslate">MaxOutstanding</code> handlers are executing <code class="notranslate">process</code>,<br/>
any more will block trying to send into the filled channel buffer,<br/>
until one of the existing handlers finishes and receives from the buffer.<br/>
<strong>-</strong></p>
<p>Данный дизайн имеет проблемы: <code class="notranslate">Serve</code>  создает новую горутину для каждого входящего запроса, при этом будет запущено не более <code class="notranslate">MaxOutstanding</code> в один момент.<br/>
Если количество запросов увеличивается слишком быстро, то как результат, программа может потребовать бесконечное количество ресурсов.<br/>
Мы можем решить это изменением <code class="notranslate">Serve</code> используя изменения количества порождаемых горутин.<br/>
Вот очевидное решение, но будьте осторожны, так как оно имеет ошибку, которую позже исправим:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">Serve</span>(<span class="pl-s1">queue</span> <span class="pl-k">chan</span> <span class="pl-c1">*</span><span class="pl-smi">Request</span>) {
    <span class="pl-k">for</span> <span class="pl-s1">req</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-s1">queue</span> {
        <span class="pl-s1">sem</span> <span class="pl-c1">&lt;-</span> <span class="pl-c1">1</span>
        <span class="pl-k">go</span> <span class="pl-k">func</span>() {
            <span class="pl-en">process</span>(<span class="pl-s1">req</span>) <span class="pl-c">// Buggy; see explanation below.</span>
            <span class="pl-c1">&lt;-</span><span class="pl-s1">sem</span>
        }()
    }
}</pre></div>
<p>Ошибка в том, что в языке Go цикл <code class="notranslate">for</code>, цикл переменной повторно используется для каждой итерации, так что переменные <code class="notranslate">req</code> разделяется по всем горутинам.<br/>
Это не то что мы хотим.<br/>
Нам нужно убедиться, что <code class="notranslate">req</code> является уникальной для каждой горутиной.<br/>
Вот один из способов, передавать значение <code class="notranslate">req</code> как в качестве аргумента для закрытии горутины:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">Serve</span>(<span class="pl-s1">queue</span> <span class="pl-k">chan</span> <span class="pl-c1">*</span><span class="pl-smi">Request</span>) {
    <span class="pl-k">for</span> <span class="pl-s1">req</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-s1">queue</span> {
        <span class="pl-s1">sem</span> <span class="pl-c1">&lt;-</span> <span class="pl-c1">1</span>
        <span class="pl-k">go</span> <span class="pl-k">func</span>(<span class="pl-s1">req</span> <span class="pl-c1">*</span><span class="pl-smi">Request</span>) {
            <span class="pl-en">process</span>(<span class="pl-s1">req</span>)
            <span class="pl-c1">&lt;-</span><span class="pl-s1">sem</span>
        }(<span class="pl-s1">req</span>)
    }
}</pre></div>
<p>Сравнивая эту версию с предыдущей можно увидеть разницу в том как объявляется запуск и закрытие.<br/>
Другое решение заключается в том что создается новая переменная с тем же именем, как в примере:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">Serve</span>(<span class="pl-s1">queue</span> <span class="pl-k">chan</span> <span class="pl-c1">*</span><span class="pl-smi">Request</span>) {
    <span class="pl-k">for</span> <span class="pl-s1">req</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-s1">queue</span> {
        <span class="pl-s1">req</span> <span class="pl-c1">:=</span> <span class="pl-s1">req</span> <span class="pl-c">// Create new instance of req for the goroutine.</span>
        <span class="pl-s1">sem</span> <span class="pl-c1">&lt;-</span> <span class="pl-c1">1</span>
        <span class="pl-k">go</span> <span class="pl-k">func</span>() {
            <span class="pl-en">process</span>(<span class="pl-s1">req</span>)
            <span class="pl-c1">&lt;-</span><span class="pl-s1">sem</span>
        }()
    }
}</pre></div>
<p>Может кажется странным, писать:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-s1">req</span> <span class="pl-c1">:=</span> <span class="pl-s1">req</span></pre></div>
<p>Но это допустимо и идиоматично делать это.<br/>
Вы получаете новую переменную с тем же именем, намеренно затеняя переменную цикла локально, но уникальный для каждой горутины.</p>
<p>Возвращаясь к общей проблеме написания сервера, иной подход для управления ресурсами начинается с фиксации числа обработчиков <code class="notranslate">handle</code> горутин читающих из канала запросов.<br/>
Ограничение количества горутин количеством одновременных вызовов к <code class="notranslate">process</code>.</p>
<p>Функция <code class="notranslate">Serve</code> также принимает канал, на который посылается об окончании; после запуска горутины блокируют получающих в этот канал.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">handle</span>(<span class="pl-s1">queue</span> <span class="pl-k">chan</span> <span class="pl-c1">*</span><span class="pl-smi">Request</span>) {
    <span class="pl-k">for</span> <span class="pl-s1">r</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-s1">queue</span> {
        <span class="pl-en">process</span>(<span class="pl-s1">r</span>)
    }
}

<span class="pl-k">func</span> <span class="pl-en">Serve</span>(<span class="pl-s1">clientRequests</span> <span class="pl-k">chan</span> <span class="pl-c1">*</span><span class="pl-smi">Request</span>, <span class="pl-s1">quit</span> <span class="pl-k">chan</span> <span class="pl-smi">bool</span>) {
    <span class="pl-c">// Start handlers</span>
    <span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">:=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">MaxOutstanding</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span> {
        <span class="pl-k">go</span> <span class="pl-en">handle</span>(<span class="pl-s1">clientRequests</span>)
    }
    <span class="pl-c1">&lt;-</span><span class="pl-s1">quit</span>  <span class="pl-c">// Wait to be told to exit.</span>
}</pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="VsPAwkhqLJAOplVM">Канал каналов (Channels of channels)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Одно из важных свойств Go в том что каналы это переменная, а значит аллоцированы и могут передаваться как любой другой элемент. Одно из использований данной свойства в реализации безопасного и <strong>параллельного демультиплексирования</strong>.</p>
<p>В примере из предыдущего раздела, <code class="notranslate">handle</code> был идеальным обработчиком для запросов, но он не определял тип обработки. Если тип включен в канал, на который отвечать, то каждый клиент может предоставить собственный путь для ответа. Вот схематичное определение типа <code class="notranslate">Request</code>.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">Request</span> <span class="pl-k">struct</span> {
    <span class="pl-c1">args</span>        []<span class="pl-smi">int</span>
    <span class="pl-c1">f</span>           <span class="pl-k">func</span>([]<span class="pl-smi">int</span>) <span class="pl-smi">int</span>
    <span class="pl-c1">resultChan</span>  <span class="pl-k">chan</span> <span class="pl-smi">int</span>
}</pre></div>
<p>Клиент предоставляет функцию и ее аргументы, а также канал внутри объекта запроса, не который будет получен ответ.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">sum</span>(<span class="pl-s1">a</span> []<span class="pl-smi">int</span>) (<span class="pl-s1">s</span> <span class="pl-smi">int</span>) {
    <span class="pl-k">for</span> <span class="pl-s1">_</span>, <span class="pl-s1">v</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-s1">a</span> {
        <span class="pl-s1">s</span> <span class="pl-c1">+=</span> <span class="pl-s1">v</span>
    }
    <span class="pl-k">return</span>
}

<span class="pl-s1">request</span> <span class="pl-c1">:=</span> <span class="pl-c1">&amp;</span><span class="pl-smi">Request</span>{[]<span class="pl-smi">int</span>{<span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>}, <span class="pl-s1">sum</span>, <span class="pl-en">make</span>(<span class="pl-k">chan</span> <span class="pl-smi">int</span>)}
<span class="pl-c">// Send request</span>
<span class="pl-s1">clientRequests</span> <span class="pl-c1">&lt;-</span> <span class="pl-s1">request</span>
<span class="pl-c">// Wait for response.</span>
<span class="pl-s1">fmt</span>.<span class="pl-en">Printf</span>(<span class="pl-s">&#34;answer: %d<span class="pl-cce">\n</span>&#34;</span>, <span class="pl-c1">&lt;-</span><span class="pl-s1">request</span>.<span class="pl-c1">resultChan</span>)</pre></div>
<p>На стороне сервера, функция обработчик это единственное что меняется.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">handle</span>(<span class="pl-s1">queue</span> <span class="pl-k">chan</span> <span class="pl-c1">*</span><span class="pl-smi">Request</span>) {
    <span class="pl-k">for</span> <span class="pl-s1">req</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-s1">queue</span> {
        <span class="pl-s1">req</span>.<span class="pl-c1">resultChan</span> <span class="pl-c1">&lt;-</span> <span class="pl-s1">req</span>.<span class="pl-en">f</span>(<span class="pl-s1">req</span>.<span class="pl-c1">args</span>)
    }
}</pre></div>
<p>Этот пример является примером основой для ограничения скорости, параллелизма, неблокирующей RPC системы и без использования мютекса.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="MnpoVhxOzInvuCqg">Параллелизм (Parallelization)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Другой пример использования этих идей в расчёте на нескольких ядрах CPU. Если расчет можно разбить на кусочки выполняющиеся независимо, то это можно распараллелить с каналами сигнализирующие, когда отдельный кусочек закончил свою работу.</p>
<p>К примеру, у нас есть дорогая операция выполнения на векторе элементов и эти операции могут выполнять независимо, то вот идеализированный пример.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">Vector</span> []<span class="pl-smi">float64</span>

<span class="pl-c">// Apply the operation to v[i], v[i+1] ... up to v[n-1].</span>
<span class="pl-k">func</span> (<span class="pl-s1">v</span> <span class="pl-smi">Vector</span>) <span class="pl-en">DoSome</span>(<span class="pl-s1">i</span>, <span class="pl-s1">n</span> <span class="pl-smi">int</span>, <span class="pl-s1">u</span> <span class="pl-smi">Vector</span>, <span class="pl-s1">c</span> <span class="pl-k">chan</span> <span class="pl-smi">int</span>) {
    <span class="pl-k">for</span> ; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">n</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span> {
        <span class="pl-s1">v</span>[<span class="pl-s1">i</span>] <span class="pl-c1">+=</span> <span class="pl-s1">u</span>.<span class="pl-en">Op</span>(<span class="pl-s1">v</span>[<span class="pl-s1">i</span>])
    }
    <span class="pl-s1">c</span> <span class="pl-c1">&lt;-</span> <span class="pl-c1">1</span>    <span class="pl-c">// signal that this piece is done</span>
}</pre></div>
<p>Вы выполняем кусочки независимо в цикле, по одному CPU на кусочек.<br/>
Они могут закончить в любом порядке, но это не важно; мы только считаем количество сигналов окончания по каналу после запуска всех горутин.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">const</span> <span class="pl-s1">numCPU</span> <span class="pl-c1">=</span> <span class="pl-c1">4</span> <span class="pl-c">// number of CPU cores</span>

<span class="pl-k">func</span> (<span class="pl-s1">v</span> <span class="pl-smi">Vector</span>) <span class="pl-en">DoAll</span>(<span class="pl-s1">u</span> <span class="pl-smi">Vector</span>) {
    <span class="pl-s1">c</span> <span class="pl-c1">:=</span> <span class="pl-en">make</span>(<span class="pl-k">chan</span> <span class="pl-smi">int</span>, <span class="pl-s1">numCPU</span>)  <span class="pl-c">// Buffering optional but sensible.</span>
    <span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">:=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">numCPU</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span> {
        <span class="pl-k">go</span> <span class="pl-s1">v</span>.<span class="pl-en">DoSome</span>(<span class="pl-s1">i</span><span class="pl-c1">*</span><span class="pl-en">len</span>(<span class="pl-s1">v</span>)<span class="pl-c1">/</span><span class="pl-s1">numCPU</span>, (<span class="pl-s1">i</span><span class="pl-c1">+</span><span class="pl-c1">1</span>)<span class="pl-c1">*</span><span class="pl-en">len</span>(<span class="pl-s1">v</span>)<span class="pl-c1">/</span><span class="pl-s1">numCPU</span>, <span class="pl-s1">u</span>, <span class="pl-s1">c</span>)
    }
    <span class="pl-c">// Drain the channel.</span>
    <span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">:=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">numCPU</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span> {
        <span class="pl-c1">&lt;-</span><span class="pl-s1">c</span>    <span class="pl-c">// wait for one task to complete</span>
    }
    <span class="pl-c">// All done.</span>
}</pre></div>
<p>Вместо того, чтобы создать постоянное значение для numCPU, мы можем задать во время выполнения необходимое значение.<br/>
Функция <a href="https://golang.org/pkg/runtime/#NumCPU" rel="nofollow">runtime.NumCPU</a> возвращает количество ядер CPU в машине, тогда мы должны записать:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">var</span> <span class="pl-s1">numCPU</span> <span class="pl-c1">=</span> <span class="pl-s1">runtime</span>.<span class="pl-en">NumCPU</span>()</pre></div>
<p>Есть также такая функция <a href="https://golang.org/pkg/runtime/#GOMAXPROCS" rel="nofollow">runtime.GOMAXPROCS</a>, которая возвращает заданное пользователем количество ядер, которая программа Go может использовать.<br/>
По умолчанию значение <code class="notranslate">runtime.NumCPU</code>, но может быть переопределен путем установки в среде с тем же именем или вызовом функции с положительным числом.<br/>
Вызов с нулевым значением запрашивает значение.<br/>
Поэтому если мы хотим выполнить запрос ресурсов пользователя, мы должны написать</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">var</span> <span class="pl-s1">numCPU</span> <span class="pl-c1">=</span> <span class="pl-s1">runtime</span>.<span class="pl-en">GOMAXPROCS</span>(<span class="pl-c1">0</span>)</pre></div>
<p>Будьте уверены, чтобы не путать идеи параллельно-структурированной(<strong>concurrency—structuring</strong>) программы как независимо исполняемых компонентов и параллельно-выполняемые вычисления(<strong>parallelism—executing</strong>) для эффективности на нескольких процессорах.<br/>
Хотя особенности <em>concurrency</em> в языке Go могут решить некоторые проблемы легко с использованием структур параллельного вычисления, Go является <em>concurrent</em> языком, не параллельным и не все проблемы параллелизма подходят модели Go.<br/>
Для обсуждения различий, смотрите <a href="https://blog.golang.org/concurrency-is-not-parallelism" rel="nofollow">следующий блог</a>.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="aWzGlHZYBYXlCyRO">Текущий буфер (A leaky buffer)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Инструменты конкарентси программирования позволяют для неконкаренси идей быть нагляднее. Вот пример из пакета RPC.  Цикл клиента горутины принимает данные из нескольких источников, возможно из сети. Для того чтобы избежать выделения и освобождения буферов, он пустой список и использует буферизованный канал для его представления. Если канал пуст, то выделяется новый буфер. После того, как буфер готов, он высылает на сервер на <code class="notranslate">serverChan</code>.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">var</span> <span class="pl-s1">freeList</span> <span class="pl-c1">=</span> <span class="pl-en">make</span>(<span class="pl-k">chan</span> <span class="pl-c1">*</span><span class="pl-smi">Buffer</span>, <span class="pl-c1">100</span>)
<span class="pl-k">var</span> <span class="pl-s1">serverChan</span> <span class="pl-c1">=</span> <span class="pl-en">make</span>(<span class="pl-k">chan</span> <span class="pl-c1">*</span><span class="pl-smi">Buffer</span>)

<span class="pl-k">func</span> <span class="pl-en">client</span>() {
    <span class="pl-k">for</span> {
        <span class="pl-k">var</span> <span class="pl-s1">b</span> <span class="pl-c1">*</span><span class="pl-smi">Buffer</span>
        <span class="pl-c">// Grab a buffer if available; allocate if not.</span>
        <span class="pl-k">select</span> {
        <span class="pl-k">case</span> <span class="pl-s1">b</span> <span class="pl-c1">=</span> <span class="pl-c1">&lt;-</span><span class="pl-s1">freeList</span>:
            <span class="pl-c">// Got one; nothing more to do.</span>
        <span class="pl-k">default</span>:
            <span class="pl-c">// None free, so allocate a new one.</span>
            <span class="pl-s1">b</span> <span class="pl-c1">=</span> <span class="pl-en">new</span>(<span class="pl-smi">Buffer</span>)
        }
        <span class="pl-en">load</span>(<span class="pl-s1">b</span>)              <span class="pl-c">// Read next message from the net.</span>
        <span class="pl-s1">serverChan</span> <span class="pl-c1">&lt;-</span> <span class="pl-s1">b</span>      <span class="pl-c">// Send to server.</span>
    }
}</pre></div>
<p>Цикл сервера принимает каждое сообщение из клиента, обрабатывает его и возвращает буфер на пустое список.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">server</span>() {
    <span class="pl-k">for</span> {
        <span class="pl-s1">b</span> <span class="pl-c1">:=</span> <span class="pl-c1">&lt;-</span><span class="pl-s1">serverChan</span>    <span class="pl-c">// Wait for work.</span>
        <span class="pl-en">process</span>(<span class="pl-s1">b</span>)
        <span class="pl-c">// Reuse buffer if there&#39;s room.</span>
        <span class="pl-k">select</span> {
        <span class="pl-k">case</span> <span class="pl-s1">freeList</span> <span class="pl-c1">&lt;-</span> <span class="pl-s1">b</span>:
            <span class="pl-c">// Buffer on free list; nothing more to do.</span>
        <span class="pl-k">default</span>:
            <span class="pl-c">// Free list full, just carry on.</span>
        }
    }
}</pre></div>
<p>Клиент пытается получить буфер из <code class="notranslate">freeList</code>; если ни один не доступен, он выделяется новые.<br/>
Посылка от сервера в <code class="notranslate">freeList</code> подставляется назад <code class="notranslate">b</code> в свободный список, если список не полон, и в этом случаи буфер сбрасывается, чтобы утилизироваться сборщиком мусора.</p>
<p>(Положение <code class="notranslate">default</code> в <code class="notranslate">select</code> выполняется когда другие условия не готовы, это означает что  <code class="notranslate">selects</code> никогда не блокируется.)<br/>
Эта реализация устроена как утекающее ведро со свободным списком всего в несколько строк, опираясь на буферизованный канал и сборщик мусора.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h2 id="QMKXZiqHrlqphAah">Ошибки (Errors)</h2>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Библиотеки подпрограмм часто должны возвращать какой-то признак ошибки для вызывающего.<br/>
Как уже упоминалось ранее, множественные значения в Go могут легко возвращать подробное описание ошибки вместе с нормальным возвращением значения.<br/>
Использование данной особенности Go для возвращения детального описания ошибки является хорошим стилем.<br/>
Например, как вы увидите <code class="notranslate">os.Open</code> при неудаче не просто возвращает указатель на  <code class="notranslate">nil</code>, он также возвращает значение ошибки, описывающей что пошло не так.</p>
<p>В соответствии с соглашением, ошибки имеют тип <code class="notranslate">error</code>, простой встроенный интерфейс.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">type</span> <span class="pl-smi">error</span> <span class="pl-k">interface</span> {
    <span class="pl-c1">Error</span>() <span class="pl-smi">string</span>
}</pre></div>
<p>Библиотека записи может реализовать данный интерфейс с богатой моделью покрытия, что позволяет не только увидеть ошибку, но и также обеспечить некий контекст.<br/>
Как уже отмечалось, наряду с обычным <code class="notranslate">*os.File</code> возвращением значения, <code class="notranslate">os.Open</code> также возвращает значение ошибки.<br/>
Если файл будет успешно открыт то значение ошибки будет <code class="notranslate">nil</code>, но когда есть проблема, то будет передана <code class="notranslate">os.PathError</code>:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// PathError records an error and the operation and</span>
<span class="pl-c">// file path that caused it.</span>
<span class="pl-k">type</span> <span class="pl-smi">PathError</span> <span class="pl-k">struct</span> {
    <span class="pl-c1">Op</span> <span class="pl-smi">string</span>    <span class="pl-c">// &#34;open&#34;, &#34;unlink&#34;, etc.</span>
    <span class="pl-c1">Path</span> <span class="pl-smi">string</span>  <span class="pl-c">// The associated file.</span>
    <span class="pl-c1">Err</span> <span class="pl-smi">error</span>    <span class="pl-c">// Returned by the system call.</span>
}

<span class="pl-k">func</span> (<span class="pl-s1">e</span> <span class="pl-c1">*</span> <span class="pl-smi">PathError</span>) <span class="pl-en">Error</span>() <span class="pl-smi">string</span> {
    <span class="pl-k">return</span> <span class="pl-s1">e</span>.<span class="pl-c1">Op</span> <span class="pl-c1">+</span> <span class="pl-s">&#34; &#34;</span> <span class="pl-c1">+</span> <span class="pl-s1">e</span>.<span class="pl-c1">Path</span> <span class="pl-c1">+</span> <span class="pl-s">&#34;: &#34;</span> <span class="pl-c1">+</span> <span class="pl-s1">e</span>.<span class="pl-c1">Err</span>.<span class="pl-en">Error</span>()
}</pre></div>
<p>Ошибка <code class="notranslate">Error</code> в <code class="notranslate">PathError</code> сгенерирует строку как эта:</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">open /etc/passwx: no such file or directory</pre></div>
<p>Такая ошибка, которая включает имя проблемного файла, операции, ошибка операционной системы и т.д., полезная, даже если напечатать далеко от вызова; это гораздо полезнее, что просто запись &#34;файл или папка не найдены&#34;.</p>
<p>Если это возможно, то строка ошибки должна определять происхождение, например, при наличии префикса имен операции или пакета, который вызвал ошибку.<br/>
Например, в пакете <code class="notranslate">image</code> при ошибки декодирования представлена от неизвестного формата: &#34;image: unknown format&#34;.</p>
<p>Вызывающие, которые заботятся о точности ошибки, могут использовать переключатель типов <em>type switch</em> или <em>type assertion</em> для того специфицирования ошибок и получения большего количества деталей. Для <code class="notranslate">PathErrors</code> это означает включения изучения внутренних полей <code class="notranslate">Err</code> для восстановления причины отказа.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">for</span> <span class="pl-s1">try</span> <span class="pl-c1">:=</span> <span class="pl-c1">0</span>; <span class="pl-s1">try</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">2</span>; <span class="pl-s1">try</span><span class="pl-c1">++</span> {
    <span class="pl-s1">file</span>, <span class="pl-s1">err</span> <span class="pl-c1">=</span> <span class="pl-s1">os</span>.<span class="pl-en">Create</span>(<span class="pl-s1">filename</span>)
    <span class="pl-k">if</span> <span class="pl-s1">err</span> <span class="pl-c1">==</span> <span class="pl-c1">nil</span> {
        <span class="pl-k">return</span>
    }
    <span class="pl-k">if</span> <span class="pl-s1">e</span>, <span class="pl-s1">ok</span> <span class="pl-c1">:=</span> <span class="pl-s1">err</span>.(<span class="pl-c1">*</span>os.<span class="pl-smi">PathError</span>); <span class="pl-s1">ok</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-s1">e</span>.<span class="pl-c1">Err</span> <span class="pl-c1">==</span> <span class="pl-s1">syscall</span>.<span class="pl-c1">ENOSPC</span> {
        <span class="pl-en">deleteTempFiles</span>()  <span class="pl-c">// Recover some space.</span>
        <span class="pl-k">continue</span>
    }
    <span class="pl-k">return</span>
}</pre></div>
<p>Здесь вторая проверка <code class="notranslate">if</code> это ещё другой тип <em>type assertion</em>.<br/>
Если это не удается, то <code class="notranslate">ok</code> будет <em>false</em> и значение <code class="notranslate">e</code> будет <code class="notranslate">nil</code>.<br/>
Если это удается, то <code class="notranslate">ok</code> будет <em>true</em>, который означает, что имеет тип <code class="notranslate">*os.PathError</code>, и затем когда <code class="notranslate">e</code>, который мы можем рассматривать для более подробной информации об ошибке.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="MIRrRXzUWETsmcJb">Паника (Panic)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Обычный способ сообщить об ошибке к абоненту, это вернуть <code class="notranslate">error</code>, в качестве дополнительного возвращаемого значения. Канонический метод <code class="notranslate">Read</code> является хорошим примером, который возвращает количество байт и <code class="notranslate">error</code>. Но что если ошибка невосстановимая? Иногда программа просто не может продолжать работать.</p>
<p>Для этого есть встроенная функция <code class="notranslate">panic</code>, которая создаёт ошибку во время выполнения программы, которая остановит программу (но смотрите следующий раздел).<br/>
Функция принимает один аргумент произвольного типа, часто используется строка для вывода на печать, так как программа умирает. Это также путь указать, что произошло что-то невозможное, как например выход из бесконечного цикла.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// A toy implementation of cube root using Newton&#39;s method.</span>
<span class="pl-k">func</span> <span class="pl-en">CubeRoot</span>(<span class="pl-s1">x</span> <span class="pl-smi">float64</span>) <span class="pl-smi">float64</span> {
    <span class="pl-s1">z</span> <span class="pl-c1">:=</span> <span class="pl-s1">x</span><span class="pl-c1">/</span><span class="pl-c1">3</span>   <span class="pl-c">// Arbitrary initial value</span>
    <span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">:=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">1e6</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span> {
        <span class="pl-s1">prevz</span> <span class="pl-c1">:=</span> <span class="pl-s1">z</span>
        <span class="pl-s1">z</span> <span class="pl-c1">-=</span> (<span class="pl-s1">z</span><span class="pl-c1">*</span><span class="pl-s1">z</span><span class="pl-c1">*</span><span class="pl-s1">z</span><span class="pl-c1">-</span><span class="pl-s1">x</span>) <span class="pl-c1">/</span> (<span class="pl-c1">3</span><span class="pl-c1">*</span><span class="pl-s1">z</span><span class="pl-c1">*</span><span class="pl-s1">z</span>)
        <span class="pl-k">if</span> <span class="pl-en">veryClose</span>(<span class="pl-s1">z</span>, <span class="pl-s1">prevz</span>) {
            <span class="pl-k">return</span> <span class="pl-s1">z</span>
        }
    }
    <span class="pl-c">// A million iterations has not converged; something is wrong.</span>
    <span class="pl-en">panic</span>(<span class="pl-s1">fmt</span>.<span class="pl-en">Sprintf</span>(<span class="pl-s">&#34;CubeRoot(%g) did not converge&#34;</span>, <span class="pl-s1">x</span>))
}</pre></div>
<p>Это всего лишь пример и в реальных библиотечных функциях следует избегать <code class="notranslate">panic</code>. Если проблема может быть замаскирована или работать по другому алгоритму, то это всегда лучше, чтобы программа продолжала работать, а не выключать её. Один из возможных примеров: если библиотека действительно не может это сделать, то это причина паниковать.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">var</span> <span class="pl-s1">user</span> <span class="pl-c1">=</span> <span class="pl-s1">os</span>.<span class="pl-en">Getenv</span>(<span class="pl-s">&#34;USER&#34;</span>)

<span class="pl-k">func</span> <span class="pl-en">init</span>() {
    <span class="pl-k">if</span> <span class="pl-s1">user</span> <span class="pl-c1">==</span> <span class="pl-s">&#34;&#34;</span> {
        <span class="pl-en">panic</span>(<span class="pl-s">&#34;no value for $USER&#34;</span>)
    }
}</pre></div>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h3 id="rBrKsJLmdmQPsCIA">Восстановление (Recover)</h3>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Когда вызывается <code class="notranslate">panic</code>, в том числе не явно при наличии ошибок во время выполнения программы, к примеру когда происходит обращение к срезу за его пределами или при некорректной работы с типами, происходит немедленное прекращение работы функции и начинается раскручивание стека горутин, запуск всех отсроченных функций <em>defer</em>.<br/>
Если раскручивание достигает вершины стека, то программа умирает. Тем не менее, можно использовать встроенную функцию <code class="notranslate">recover</code>, чтобы восстановить контроль над горутинами и возобновить нормальное выполнение.</p>
<p>Вызов <code class="notranslate">recover</code> останавливает раскручивание и возвращает аргументы в <code class="notranslate">panic</code>. Поскольку только код, который работает во время раскручивания внутри отложенных функций, <code class="notranslate">recover</code> полезно устанавливать внутри отложенных функций.</p>
<p>Одно <code class="notranslate">recover</code> приложение выключает недопустимые горутины изнутри, то сервер без выключения других запущенных горутин.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">func</span> <span class="pl-en">server</span>(<span class="pl-s1">workChan</span> <span class="pl-c1">&lt;-</span><span class="pl-k">chan</span> <span class="pl-c1">*</span><span class="pl-smi">Work</span>) {
    <span class="pl-k">for</span> <span class="pl-s1">work</span> <span class="pl-c1">:=</span> <span class="pl-k">range</span> <span class="pl-s1">workChan</span> {
        <span class="pl-k">go</span> <span class="pl-en">safelyDo</span>(<span class="pl-s1">work</span>)
    }
}

<span class="pl-k">func</span> <span class="pl-en">safelyDo</span>(<span class="pl-s1">work</span> <span class="pl-c1">*</span><span class="pl-smi">Work</span>) {
    <span class="pl-k">defer</span> <span class="pl-k">func</span>() {
        <span class="pl-k">if</span> <span class="pl-s1">err</span> <span class="pl-c1">:=</span> <span class="pl-en">recover</span>(); <span class="pl-s1">err</span> <span class="pl-c1">!=</span> <span class="pl-c1">nil</span> {
            <span class="pl-s1">log</span>.<span class="pl-en">Println</span>(<span class="pl-s">&#34;work failed:&#34;</span>, <span class="pl-s1">err</span>)
        }
    }()
    <span class="pl-en">do</span>(<span class="pl-s1">work</span>)
}</pre></div>
<p>В этом примере, если будет вызвана паника в  <code class="notranslate">do(work)</code>, то результат будет залогирован и горутина закончит работу без препятствия выполнения для других. Там нет необходимости делать что то дополнительно при отсроченном выполнении; вызывание <code class="notranslate">recover</code> обрабатывает состояние полностью.</p>
<p>Так как <code class="notranslate">recover</code> всегда возвращает <code class="notranslate">nil</code>, если вызывалась из отложенной функции, отложенный код может вызывать библиотеку функций, которые сами используют <code class="notranslate">panic</code> и <code class="notranslate">recover</code> без сбоя.<br/>
К примеру, отложенная функция в <code class="notranslate">safelyDo</code> может вызвать функцию логирования до вызова <code class="notranslate">recover</code>, и этот код логирования будет работать не зависимо от состоянии паники.</p>
<p>С помощью данного шаблона восстановления , функция <code class="notranslate">do</code> (и все что он вызывает) может выйти из любой ситуации вызовом <code class="notranslate">panic</code>.<br/>
Мы можем использовать данную идею для простой обработки ошибок в сложной программе. Давайте взглянем на идеализированную версию пакета <code class="notranslate">regexp</code>, которая сообщает об ошибке с помощью <code class="notranslate">panic</code> с типом локальной ошибки. Это определение <code class="notranslate">Error</code>, в методе <code class="notranslate">error</code> и функции <code class="notranslate">Compile</code>.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">// Error is the type of a parse error; it satisfies the error interface.</span>
<span class="pl-k">type</span> <span class="pl-smi">Error</span> <span class="pl-smi">string</span>
<span class="pl-k">func</span> (<span class="pl-s1">e</span> <span class="pl-smi">Error</span>) <span class="pl-en">Error</span>() <span class="pl-smi">string</span> {
    <span class="pl-k">return</span> <span class="pl-en">string</span>(<span class="pl-s1">e</span>)
}

<span class="pl-c">// error is a method of *Regexp that reports parsing errors by</span>
<span class="pl-c">// panicking with an Error.</span>
<span class="pl-k">func</span> (<span class="pl-s1">regexp</span> <span class="pl-c1">*</span><span class="pl-smi">Regexp</span>) <span class="pl-en">error</span>(<span class="pl-s1">err</span> <span class="pl-smi">string</span>) {
    <span class="pl-en">panic</span>(<span class="pl-en">Error</span>(<span class="pl-s1">err</span>))
}

<span class="pl-c">// Compile returns a parsed representation of the regular expression.</span>
<span class="pl-k">func</span> <span class="pl-en">Compile</span>(<span class="pl-s1">str</span> <span class="pl-smi">string</span>) (<span class="pl-s1">regexp</span> <span class="pl-c1">*</span><span class="pl-smi">Regexp</span>, <span class="pl-s1">err</span> <span class="pl-smi">error</span>) {
    <span class="pl-s1">regexp</span> <span class="pl-c1">=</span> <span class="pl-en">new</span>(<span class="pl-smi">Regexp</span>)
    <span class="pl-c">// doParse will panic if there is a parse error.</span>
    <span class="pl-k">defer</span> <span class="pl-k">func</span>() {
        <span class="pl-k">if</span> <span class="pl-s1">e</span> <span class="pl-c1">:=</span> <span class="pl-en">recover</span>(); <span class="pl-s1">e</span> <span class="pl-c1">!=</span> <span class="pl-c1">nil</span> {
            <span class="pl-s1">regexp</span> <span class="pl-c1">=</span> <span class="pl-c1">nil</span>    <span class="pl-c">// Clear return value.</span>
            <span class="pl-s1">err</span> <span class="pl-c1">=</span> <span class="pl-s1">e</span>.(<span class="pl-smi">Error</span>) <span class="pl-c">// Will re-panic if not a parse error.</span>
        }
    }()
    <span class="pl-k">return</span> <span class="pl-s1">regexp</span>.<span class="pl-en">doParse</span>(<span class="pl-s1">str</span>), <span class="pl-c1">nil</span>
}</pre></div>
<p>Если происходит паника в <code class="notranslate">doParse</code>, то блок восстановления будет устанавливать значение <code class="notranslate">nil</code> отложенная функция может модифицировать имя возвращаемых значений.<br/>
Затем он проверяет, значение <code class="notranslate">err</code>, синтаксическая ошибка имеет локальный тип <code class="notranslate">Error</code>. Если этого не произойдет, то это приведет к ошибке во время выполнения и будет раскручивать стек.<br/>
Эта проверка означает что если происходит что-то неожиданное, как выход за пределы индексирования, код будет прерван даже при использовании <code class="notranslate">panic</code> и <code class="notranslate">recover</code> для обработки ошибок.</p>
<p>При наличии обработчика ошибок, метод <code class="notranslate">error</code> (потому его метод связан с типом, это хорошо, так как он имеет то же имя что встроенный тип <code class="notranslate">error</code>) позволяет легко сообщить о наличии синтаксической ошибки, не беспокоясь о разматывания стек вручную:</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-k">if</span> <span class="pl-s1">pos</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span> {
    <span class="pl-s1">re</span>.<span class="pl-en">error</span>(<span class="pl-s">&#34;&#39;*&#39; illegal at start of expression&#34;</span>)
}</pre></div>
<p>Данный шаблон полезный в рамках только одного пакета. Превращение <code class="notranslate">Parse</code>  внутреннего вызова <code class="notranslate">panic</code> в значение <code class="notranslate">error</code>, что позволяет на выставлять <code class="notranslate">panics</code> для клиента. Это хорошее правило, чтобы ему следовать.</p>
<p>Данный подход, меняет идиому паник на значение паники если произошла ошибка.<br/>
Тем не менее, как оригинальная, так и новые сбои будут представлены в отчёте сбоев, поэтому основная причина этой проблемы не будет видна.<br/>
Если Вы хотите увидеть только оригинальные значения, Вам необходимо немного больше кода для фильтрации неожиданных проблем и повторно паниковать с оригинальной ошибкой.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<h2 id="ADRNiLJuOnBDKhbB">Веб-сервер</h2>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<p>Давайте закончим разработкой веб-сервера на Go.<br/>
Google предоставлен сервис по адресу <a href="http://chart.apis.google.com" rel="nofollow">http://chart.apis.google.com</a> с автоматическим форматированием данных графиков и диаграмм.<br/>
Это трудно использовать в интерактивном режиме, но Вам необходимо добавить URL в качестве запроса.<br/>
Здесь программа использует приятный простой интерфейс с одной формой для данных: для небольшого кусочка текста, который вызывает сервер диаграмм для создания QR кода, кодируя текст в матрицу пиксел.<br/>
Эта картинка можно быть сфотографирована с помощью камеры телефона и интерпретирована, к примеру, как URL, экономя тем самым его набор на маленькой клавиатуре телефона.</p>
<p>Вот программа полностью с последующими пояснениями.</p>
<div class="highlight highlight-source-go"><pre class="notranslate"><span class="pl-c">//{{code &#34;/doc/progs/eff_qr.go&#34; `/package/` `$`}}</span>
<span class="pl-c">// Copyright 2009 The Go Authors. All rights reserved.</span>
<span class="pl-c">// Use of this source code is governed by a BSD-style</span>
<span class="pl-c">// license that can be found in the LICENSE file.</span>

<span class="pl-k">package</span> main

<span class="pl-k">import</span> (
	<span class="pl-s">&#34;flag&#34;</span>
	<span class="pl-s">&#34;html/template&#34;</span>
	<span class="pl-s">&#34;log&#34;</span>
	<span class="pl-s">&#34;net/http&#34;</span>
)

<span class="pl-k">var</span> <span class="pl-s1">addr</span> <span class="pl-c1">=</span> <span class="pl-s1">flag</span>.<span class="pl-en">String</span>(<span class="pl-s">&#34;addr&#34;</span>, <span class="pl-s">&#34;:1718&#34;</span>, <span class="pl-s">&#34;http service address&#34;</span>) <span class="pl-c">// Q=17, R=18</span>

<span class="pl-k">var</span> <span class="pl-s1">templ</span> <span class="pl-c1">=</span> <span class="pl-s1">template</span>.<span class="pl-en">Must</span>(<span class="pl-s1">template</span>.<span class="pl-en">New</span>(<span class="pl-s">&#34;qr&#34;</span>).<span class="pl-en">Parse</span>(<span class="pl-s1">templateStr</span>))

<span class="pl-k">func</span> <span class="pl-en">main</span>() {
	<span class="pl-s1">flag</span>.<span class="pl-en">Parse</span>()
	<span class="pl-s1">http</span>.<span class="pl-en">Handle</span>(<span class="pl-s">&#34;/&#34;</span>, <span class="pl-s1">http</span>.<span class="pl-en">HandlerFunc</span>(<span class="pl-s1">QR</span>))
	<span class="pl-s1">err</span> <span class="pl-c1">:=</span> <span class="pl-s1">http</span>.<span class="pl-en">ListenAndServe</span>(<span class="pl-c1">*</span><span class="pl-s1">addr</span>, <span class="pl-c1">nil</span>)
	<span class="pl-k">if</span> <span class="pl-s1">err</span> <span class="pl-c1">!=</span> <span class="pl-c1">nil</span> {
		<span class="pl-s1">log</span>.<span class="pl-en">Fatal</span>(<span class="pl-s">&#34;ListenAndServe:&#34;</span>, <span class="pl-s1">err</span>)
	}
}

<span class="pl-k">func</span> <span class="pl-en">QR</span>(<span class="pl-s1">w</span> http.<span class="pl-smi">ResponseWriter</span>, <span class="pl-s1">req</span> <span class="pl-c1">*</span>http.<span class="pl-smi">Request</span>) {
	<span class="pl-s1">templ</span>.<span class="pl-en">Execute</span>(<span class="pl-s1">w</span>, <span class="pl-s1">req</span>.<span class="pl-en">FormValue</span>(<span class="pl-s">&#34;s&#34;</span>))
}

<span class="pl-k">const</span> <span class="pl-s1">templateStr</span> <span class="pl-c1">=</span> <span class="pl-s">`</span>
<span class="pl-s">&lt;html&gt;</span>
<span class="pl-s">&lt;head&gt;</span>
<span class="pl-s">&lt;title&gt;QR Link Generator&lt;/title&gt;</span>
<span class="pl-s">&lt;/head&gt;</span>
<span class="pl-s">&lt;body&gt;</span>
<span class="pl-s">{{if .}}</span>
<span class="pl-s">&lt;img src=&#34;http://chart.apis.google.com/chart?chs=300x300&amp;cht=qr&amp;choe=UTF-8&amp;chl={{.}}&#34; /&gt;</span>
<span class="pl-s">&lt;br&gt;</span>
<span class="pl-s">{{.}}</span>
<span class="pl-s">&lt;br&gt;</span>
<span class="pl-s">&lt;br&gt;</span>
<span class="pl-s">{{end}}</span>
<span class="pl-s">&lt;form action=&#34;/&#34; name=f method=&#34;GET&#34;&gt;&lt;input maxLength=1024 size=70</span>
<span class="pl-s">name=s value=&#34;&#34; title=&#34;Text to QR Encode&#34;&gt;&lt;input type=submit</span>
<span class="pl-s">value=&#34;Show QR&#34; name=qr&gt;</span>
<span class="pl-s">&lt;/form&gt;</span>
<span class="pl-s">&lt;/body&gt;</span>
<span class="pl-s">&lt;/html&gt;`</span></pre></div>
<p>Легко понять, что происходит в <code class="notranslate">main</code>.<br/>
Один флаг устанавливает HTTP сервер по умолчания для нашего сервера.<br/>
В значении шаблона <code class="notranslate">templ</code>, происходит самое интересное. Он конструирует шаблон HTML, который будет выполнен сервером для показа страницы. Давайте опишем, что происходит в этот момент.</p>
<p>Функция <code class="notranslate">main</code> разбирает флаги и использует механизм о котором мы говорили выше, связывает функцию <code class="notranslate">QR</code> для корневого пути для сервера.<br/>
Когда вызывается <code class="notranslate">http.ListenAndServe</code> для старта сервера, он блокируется пока сервер запущен.</p>
<p>Функция <code class="notranslate">QR</code> только получает запрос, который содержит дынные формы, и выполняет шаблон на данных в форме с именем переменной <code class="notranslate">s</code>.</p>
<p>Пакет шаблонов <code class="notranslate">html/template</code> мощный; данная программа лишь слегка затрагивает его возможности.<br/>
По сути, он переписывает часть текста HTML на лету, заменяя элементы на элементы данных, передаваемые в <code class="notranslate">templ.Execute</code>, в данном случаи переменной формы.<br/>
В тексте шаблона (<code class="notranslate">templateStr</code>), имеются <em>двойные скобки разделители</em> обозначающие действия шаблона.<br/>
Участок от <code class="notranslate">{{html &#34;{{if .}}&#34;}}</code> до <code class="notranslate">{{html &#34;{{end}}&#34;}}</code> выполняются только если значения текущей элемента данных, вызывают <code class="notranslate">.</code> (точка) не пустая. То есть, если строка пуста, то данный участок шаблона игнорируется.</p>
<p>Два примере кода <code class="notranslate">{{html &#34;{{.}}&#34;}}</code> предназначены для показа существующих данных в запросе шаблона на веб странице.<br/>
Пакет шаблонов HTML автоматически обеспечивает соответствие, поэтому текст является безопасным для отображения.</p>
<p>Остальные строки шаблона, просто строки HTML , которые показываются при загрузки страницы.<br/>
Если это слишком быстрое объяснение, то смотрите <a href="https://golang.org/pkg/html/template/" rel="nofollow">документацию</a> о пакете шаблонов для большего понимания.</p>
<p>В результате у Вас есть: полезный пример веб сервера из нескольких строк кода с управлением данных текста HTML.<br/>
Язык Go достаточно мощный для создание много чего интересного за несколько строк.</p>
<p><a href="#KEjPZrtQtALYWoQv">к Оглавление</a></p>
<hr/>
<p><strong>Список дополнительных материалов:</strong></p>
<ul>
<li><a href="https://github.com/Konstantin8105/Contribution_Guide_RU">Руководство сотрудничества</a></li>
<li><a href="https://github.com/Konstantin8105/Effective_Go_RU">Эффективный Go</a></li>
</ul>
<hr/></body></html> </article></div></body>
